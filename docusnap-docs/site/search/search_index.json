{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DocuSnap-Frontend Architecture Documentation","text":"<p>Welcome to the comprehensive architecture documentation for the DocuSnap-Frontend Android application. This documentation provides a detailed analysis of the application's architecture, design patterns, core modules, and deployment strategy.</p>"},{"location":"#about-docusnap-frontend","title":"About DocuSnap-Frontend","text":"<p>DocuSnap-Frontend is an Android application designed for document scanning and form processing, providing users with an efficient and secure mobile document management solution. The application is built using modern Android development architecture and technology stack, implementing core features such as document capture, processing, management, and form field extraction.</p>"},{"location":"#documentation-structure","title":"Documentation Structure","text":"<p>This documentation is organized into the following sections:</p> <ol> <li> <p>Project Overview: Business background, target users, core features, and value proposition.</p> </li> <li> <p>Technology Stack: Analysis of the technology choices for each layer and the rationale behind these choices.</p> </li> <li> <p>Architecture Design: Overall architecture diagram, layer descriptions, and analysis of the MVVM architecture implementation.</p> </li> <li> <p>Core Modules: Detailed analysis of the four core modules - document processing, form processing, image processing, and backend communication.</p> </li> <li> <p>Typical Processes: Data flow diagrams for document scanning and form field extraction processes.</p> </li> <li> <p>Code Quality Assessment: Analysis of code structure, design pattern implementation, and code quality strengths and areas for improvement.</p> </li> <li> <p>Deployment Architecture: Production environment deployment topology, technology stack dependencies, and security considerations.</p> </li> <li> <p>Summary and Recommendations: Architecture advantages, quick start guide, and suggestions for future optimization.</p> </li> </ol>"},{"location":"#how-to-use-this-documentation","title":"How to Use This Documentation","text":"<p>This documentation is designed to be a comprehensive reference for developers working with the DocuSnap-Frontend application. It provides insights into the architecture decisions, implementation details, and best practices used in the application.</p> <p>For new developers, we recommend starting with the Project Overview and Quick Start Guide sections to get a high-level understanding of the application and how to get started with development.</p> <p>For more experienced developers looking to understand specific aspects of the application, the Core Modules and Architecture Design sections provide detailed information on the implementation details and design patterns used.</p>"},{"location":"architecture/architecture-analysis/","title":"Architecture Design Analysis","text":"<p>This section analyzes the advantages and disadvantages of the MVVM architecture used in DocuSnap-Frontend and discusses the scenarios where this architecture is most suitable.</p>"},{"location":"architecture/architecture-analysis/#advantages","title":"Advantages","text":""},{"location":"architecture/architecture-analysis/#1-separation-of-concerns","title":"1. Separation of Concerns","text":"<ul> <li>UI, business logic, and data access are clearly separated</li> <li>Each layer has well-defined responsibilities</li> <li>Improves code maintainability and readability</li> </ul>"},{"location":"architecture/architecture-analysis/#2-testability","title":"2. Testability","text":"<ul> <li>ViewModels and Repositories can be tested independently</li> <li>UI layer can be tested with previews and UI tests</li> <li>Mock dependencies facilitate unit testing</li> </ul>"},{"location":"architecture/architecture-analysis/#3-reactive-ui-updates","title":"3. Reactive UI Updates","text":"<ul> <li>Automatic UI updates through StateFlow and Compose</li> <li>Reduces manual UI update code</li> <li>Decreases the risk of inconsistent states</li> </ul>"},{"location":"architecture/architecture-analysis/#4-modular-design","title":"4. Modular Design","text":"<ul> <li>Clear boundaries between functional modules</li> <li>Facilitates team collaboration</li> <li>Supports independent development and testing of features</li> </ul>"},{"location":"architecture/architecture-analysis/#5-unidirectional-data-flow","title":"5. Unidirectional Data Flow","text":"<ul> <li>Clear and predictable data flow</li> <li>Simplified state management</li> <li>Easier debugging and issue tracking</li> </ul>"},{"location":"architecture/architecture-analysis/#disadvantages","title":"Disadvantages","text":""},{"location":"architecture/architecture-analysis/#1-initial-complexity","title":"1. Initial Complexity","text":"<ul> <li>May be overly complex for simple applications</li> <li>Requires more boilerplate code</li> <li>Initial setup takes more time</li> </ul>"},{"location":"architecture/architecture-analysis/#2-learning-curve","title":"2. Learning Curve","text":"<ul> <li>Requires understanding of multiple concepts and technologies</li> <li>May present a barrier for new developers</li> <li>Requires understanding of reactive programming model</li> </ul>"},{"location":"architecture/architecture-analysis/#3-over-engineering-risk","title":"3. Over-engineering Risk","text":"<ul> <li>May lead to excessive abstraction</li> <li>Simple features may become complex</li> <li>Requires balancing flexibility and complexity</li> </ul>"},{"location":"architecture/architecture-analysis/#4-memory-consumption","title":"4. Memory Consumption","text":"<ul> <li>Observer pattern may lead to additional memory consumption</li> <li>Requires careful lifecycle management</li> <li>Large number of state objects may increase memory pressure</li> </ul>"},{"location":"architecture/architecture-analysis/#suitable-scenarios","title":"Suitable Scenarios","text":""},{"location":"architecture/architecture-analysis/#1-complex-data-driven-applications","title":"1. Complex Data-Driven Applications","text":"<ul> <li>Multiple data sources</li> <li>Complex data transformations and processing</li> <li>Need for real-time response to data changes</li> </ul>"},{"location":"architecture/architecture-analysis/#2-applications-requiring-offline-functionality","title":"2. Applications Requiring Offline Functionality","text":"<ul> <li>Local data caching</li> <li>Online/offline state switching</li> <li>Data synchronization requirements</li> </ul>"},{"location":"architecture/architecture-analysis/#3-large-applications-with-team-collaboration","title":"3. Large Applications with Team Collaboration","text":"<ul> <li>Clear code organization structure</li> <li>Modular design facilitates division of work</li> <li>Unified architecture pattern</li> </ul>"},{"location":"architecture/architecture-analysis/#4-applications-requiring-high-testability","title":"4. Applications Requiring High Testability","text":"<ul> <li>Strict quality requirements</li> <li>Need for high test coverage</li> <li>Automated testing requirements</li> </ul>"},{"location":"architecture/architecture-analysis/#5-enterprise-applications-with-long-term-maintenance","title":"5. Enterprise Applications with Long-term Maintenance","text":"<ul> <li>Need to adapt to changing requirements</li> <li>High maintainability requirements</li> <li>Need to support long-term evolution</li> </ul>"},{"location":"architecture/architecture-analysis/#conclusion","title":"Conclusion","text":"<p>DocuSnap-Frontend, as a complex application with offline support and security requirements for document processing, benefits significantly from the MVVM architecture. This architecture provides a clear code organization structure, supports reactive UI updates, and facilitates testing and maintenance.</p> <p>The advantages of this architecture outweigh its disadvantages in this specific context, making it an appropriate choice for the application. The initial complexity and learning curve are justified by the long-term benefits in maintainability, testability, and scalability.</p>"},{"location":"architecture/mvvm-implementation/","title":"MVVM Architecture Implementation","text":"<p>DocuSnap-Frontend fully adopts the MVVM (Model-View-ViewModel) architecture pattern, which provides a clear separation of concerns and improves code maintainability and testability.</p>"},{"location":"architecture/mvvm-implementation/#mvvm-components","title":"MVVM Components","text":""},{"location":"architecture/mvvm-implementation/#model","title":"Model","text":"<ul> <li>Data Models: <code>Document</code>, <code>Form</code>, <code>ExtractedInfoItem</code>, etc.</li> <li>Data Access: Repositories and data sources (local database, remote API)</li> </ul>"},{"location":"architecture/mvvm-implementation/#view","title":"View","text":"<ul> <li>UI Components: Jetpack Compose UI components</li> <li>State Observation: Using <code>collectAsState()</code> to observe ViewModel states</li> </ul>"},{"location":"architecture/mvvm-implementation/#viewmodel","title":"ViewModel","text":"<ul> <li>State Management: Using <code>StateFlow</code> to manage UI states</li> <li>Business Logic: Handling user actions and data transformations</li> <li>Coroutine Integration: Using <code>viewModelScope</code> to manage asynchronous operations</li> </ul>"},{"location":"architecture/mvvm-implementation/#mvvm-implementation-example","title":"MVVM Implementation Example","text":"<p>Below is an example of how MVVM is implemented in the application:</p> <pre><code>// State management in ViewModel\nclass DocumentViewModel(private val repository: DocumentRepository) : ViewModel() {\n    private val _documents = MutableStateFlow&lt;List&lt;Document&gt;&gt;(emptyList())\n    val documents: StateFlow&lt;List&lt;Document&gt;&gt; = _documents.asStateFlow()\n\n    private val _isLoading = MutableStateFlow(false)\n    val isLoading: StateFlow&lt;Boolean&gt; = _isLoading.asStateFlow()\n\n    fun loadDocuments() {\n        viewModelScope.launch {\n            _isLoading.value = true\n            try {\n                val docs = repository.getAllDocuments()\n                _documents.value = docs\n            } catch (e: Exception) {\n                // Error handling\n            } finally {\n                _isLoading.value = false\n            }\n        }\n    }\n}\n\n// State collection in UI\n@Composable\nfun DocumentScreen(viewModel: DocumentViewModel) {\n    val documents by viewModel.documents.collectAsState()\n    val isLoading by viewModel.isLoading.collectAsState()\n\n    LaunchedEffect(Unit) {\n        viewModel.loadDocuments()\n    }\n\n    if (isLoading) {\n        CircularProgressIndicator()\n    } else {\n        LazyColumn {\n            items(documents) { document -&gt;\n                DocumentItem(document)\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"architecture/mvvm-implementation/#data-flow-in-mvvm","title":"Data Flow in MVVM","text":"<p>The data flow in the MVVM architecture follows a unidirectional pattern:</p> <ol> <li>User Interaction: User interacts with the UI (View)</li> <li>Action Dispatch: View dispatches actions to the ViewModel</li> <li>Data Processing: ViewModel processes the action and interacts with the Repository</li> <li>Data Retrieval: Repository retrieves data from local or remote sources</li> <li>State Update: ViewModel updates its state based on the retrieved data</li> <li>UI Update: View observes state changes and automatically updates</li> </ol> <p>This unidirectional data flow ensures that the UI is always consistent with the underlying data and simplifies debugging and testing.</p>"},{"location":"architecture/mvvm-implementation/#benefits-of-mvvm-in-docusnap-frontend","title":"Benefits of MVVM in DocuSnap-Frontend","text":"<ul> <li>Separation of Concerns: UI, business logic, and data access are clearly separated</li> <li>Testability: ViewModels and Repositories can be tested independently</li> <li>Maintainability: Each component has a single responsibility</li> <li>Reactive UI Updates: UI automatically updates in response to data changes</li> <li>Lifecycle Awareness: ViewModels survive configuration changes</li> </ul>"},{"location":"architecture/overall-architecture/","title":"Overall Architecture and Layer Description","text":"<p>DocuSnap-Frontend adopts the MVVM (Model-View-ViewModel) architecture pattern, combined with the Repository pattern and a layered architecture. This approach ensures a clear separation of concerns and improves maintainability.</p>"},{"location":"architecture/overall-architecture/#architecture-diagram","title":"Architecture Diagram","text":"<p>Note: The architecture diagram shows the relationships between different layers and components of the application.</p>"},{"location":"architecture/overall-architecture/#layer-description","title":"Layer Description","text":"<p>The application is divided into the following layers:</p>"},{"location":"architecture/overall-architecture/#ui-layer","title":"UI Layer","text":"<p>Responsibility: Build user interfaces, handle user interactions, display data</p> <p>Main Components: - <code>MainActivity</code>: Main entry point of the application - <code>JetpackCompose</code> UI components: Build declarative UIs - <code>Navigation</code> components: Manage screen navigation</p>"},{"location":"architecture/overall-architecture/#viewmodel-layer","title":"ViewModel Layer","text":"<p>Responsibility: Manage UI state, handle business logic, connect UI and data layers</p> <p>Main Components: - <code>DocumentViewModel</code>: Manage document-related operations and state - <code>ImageProcessingViewModel</code>: Handle image processing logic and state</p>"},{"location":"architecture/overall-architecture/#repository-layer","title":"Repository Layer","text":"<p>Responsibility: Abstract data access logic, coordinate multiple data sources</p> <p>Main Components: - <code>DocumentRepository</code>: Provide document data access interface</p>"},{"location":"architecture/overall-architecture/#service-layer","title":"Service Layer","text":"<p>Responsibility: Provide specific functional services, handle background operations</p> <p>Main Components: - <code>DeviceDBService</code>: Local database service - <code>JobPollingService</code>: Backend job polling service - <code>BackendApiService</code>: Backend API communication service - <code>ImageProcService</code>: Image processing service</p>"},{"location":"architecture/overall-architecture/#data-layer","title":"Data Layer","text":"<p>Responsibility: Provide data storage and access</p> <p>Main Components: - <code>Room Database</code>: Local data storage - <code>Backend API</code>: Remote service interface</p>"},{"location":"architecture/overall-architecture/#data-flow","title":"Data Flow","text":"<p>Data in the application follows a unidirectional flow principle:</p> <ol> <li>User interactions in the UI layer trigger actions in the ViewModel layer</li> <li>The ViewModel layer processes these actions and requests data from the Repository layer</li> <li>The Repository layer retrieves data from either local or remote data sources</li> <li>The data flows back through the Repository to the ViewModel</li> <li>The ViewModel updates its state, which is observed by the UI layer</li> <li>The UI layer automatically updates to reflect the new state</li> </ol> <p>This architecture provides a clear separation of concerns, improves testability, and enhances maintainability of the application.</p>"},{"location":"deployment/deployment-strategy/","title":"Deployment Strategy and Security Considerations","text":"<p>This page details the deployment strategy, security measures, and update mechanisms implemented in DocuSnap-Frontend.</p>"},{"location":"deployment/deployment-strategy/#build-and-release-process","title":"Build and Release Process","text":"<p>DocuSnap-Frontend follows a standard Android application build and release process:</p>"},{"location":"deployment/deployment-strategy/#1-version-management","title":"1. Version Management","text":"<ul> <li>Version Number: 1.1.2 (versionName)</li> <li>Build Number: 4 (versionCode)</li> <li>Version numbers are incremented with each release</li> <li>Semantic versioning is followed (MAJOR.MINOR.PATCH)</li> </ul>"},{"location":"deployment/deployment-strategy/#2-build-configuration","title":"2. Build Configuration","text":"<ul> <li>Compile SDK Version: 35</li> <li>Minimum SDK Version: 33 (Android 13)</li> <li>Target SDK Version: 35</li> <li>Java Compatibility Version: Java 11</li> <li>Build Types:</li> <li>Debug: Used during development with debugging enabled</li> <li>Release: Optimized for distribution with debugging disabled</li> </ul>"},{"location":"deployment/deployment-strategy/#3-release-channels","title":"3. Release Channels","text":"<ul> <li>Primary distribution through Google Play Store</li> <li>Support for internal testing and staged releases</li> <li>Enterprise distribution channels available</li> <li>Alpha and beta testing programs for early feedback</li> </ul>"},{"location":"deployment/deployment-strategy/#4-update-strategy","title":"4. Update Strategy","text":"<ul> <li>In-app update notifications</li> <li>Regular feature updates and security patches</li> <li>Forced update mechanism for critical security fixes</li> <li>Phased rollouts for major updates</li> </ul>"},{"location":"deployment/deployment-strategy/#data-encryption-and-secure-communication","title":"Data Encryption and Secure Communication","text":"<p>DocuSnap-Frontend implements multiple layers of security to protect user data:</p>"},{"location":"deployment/deployment-strategy/#1-transport-encryption","title":"1. Transport Encryption","text":"<ul> <li>HTTPS Communication: All network traffic uses secure HTTPS</li> <li>RSA Public Key Encryption: 2048-bit keys</li> <li>AES-CBC Symmetric Encryption: 256-bit keys</li> <li>Encryption Modes:</li> <li>RSA/ECB/OAEPWithSHA-256AndMGF1Padding</li> <li>AES/CBC/PKCS7Padding</li> </ul> <p>Example of the hybrid encryption implementation:</p> <pre><code>// Generate AES key\nval aesKey = cryptoUtil.generateAesKey()\nval encryptedContent = cryptoUtil.aesEncrypt(innerJson.toString().toByteArray(), aesKey)\nval sha256 = cryptoUtil.computeSHA256(encryptedContent)\nval encryptedAesKey = cryptoUtil.rsaEncrypt(aesKey, cryptoUtil.getPublicKey(settingsManager.getPublicKeyPem()))\n</code></pre>"},{"location":"deployment/deployment-strategy/#2-data-integrity","title":"2. Data Integrity","text":"<ul> <li>SHA-256 Hash Verification: Ensures data hasn't been tampered with</li> <li>Digital Signature Verification: Validates data source</li> <li>Tamper-proof Mechanisms: Detects unauthorized modifications</li> </ul>"},{"location":"deployment/deployment-strategy/#3-local-security","title":"3. Local Security","text":"<ul> <li>Sensitive data is encrypted before local storage</li> <li>Android KeyStore system protects encryption keys</li> <li>Secure export mechanisms for data sharing</li> </ul>"},{"location":"deployment/deployment-strategy/#pin-code-protection-and-local-security","title":"PIN Code Protection and Local Security","text":"<p>DocuSnap-Frontend provides additional local security mechanisms:</p>"},{"location":"deployment/deployment-strategy/#1-pin-code-protection","title":"1. PIN Code Protection","text":"<ul> <li>Optional application PIN code protection</li> <li>PIN codes are hashed before storage</li> <li>Support for biometric authentication (fingerprint, face recognition)</li> <li>Configurable security timeout</li> </ul>"},{"location":"deployment/deployment-strategy/#2-session-management","title":"2. Session Management","text":"<ul> <li>Application automatically locks after a period of inactivity</li> <li>Configurable session timeout duration</li> <li>Data protection when switching applications</li> <li>Re-authentication required for sensitive operations</li> </ul>"},{"location":"deployment/deployment-strategy/#3-permission-management","title":"3. Permission Management","text":"<ul> <li>Follows the principle of least privilege</li> <li>Runtime permission requests with clear explanations</li> <li>Permissions are requested only when needed</li> <li>Users can revoke permissions at any time</li> </ul>"},{"location":"deployment/deployment-strategy/#4-data-isolation","title":"4. Data Isolation","text":"<ul> <li>Application uses private storage</li> <li>Content provider access control</li> <li>Sandbox execution environment</li> <li>No unnecessary data sharing with other applications</li> </ul>"},{"location":"deployment/deployment-strategy/#deployment-optimization","title":"Deployment Optimization","text":"<p>The deployment strategy includes several optimizations:</p>"},{"location":"deployment/deployment-strategy/#1-application-size-optimization","title":"1. Application Size Optimization","text":"<ul> <li>Resource compression</li> <li>Image optimization</li> <li>Unused resource removal</li> <li>Language-specific resource packaging</li> </ul>"},{"location":"deployment/deployment-strategy/#2-performance-optimization","title":"2. Performance Optimization","text":"<ul> <li>Startup time optimization</li> <li>Memory usage optimization</li> <li>Battery usage optimization</li> <li>Network usage optimization</li> </ul>"},{"location":"deployment/deployment-strategy/#3-compatibility-optimization","title":"3. Compatibility Optimization","text":"<ul> <li>Device-specific optimizations</li> <li>Screen size adaptations</li> <li>Hardware feature detection</li> <li>Graceful degradation for missing features</li> </ul>"},{"location":"deployment/deployment-strategy/#continuous-integration-and-delivery","title":"Continuous Integration and Delivery","text":"<p>While not currently implemented, the following CI/CD improvements are recommended:</p>"},{"location":"deployment/deployment-strategy/#1-automated-building","title":"1. Automated Building","text":"<ul> <li>Implement automated builds for each commit</li> <li>Run unit tests as part of the build process</li> <li>Generate build artifacts automatically</li> </ul>"},{"location":"deployment/deployment-strategy/#2-automated-testing","title":"2. Automated Testing","text":"<ul> <li>Run automated UI tests</li> <li>Perform integration testing</li> <li>Execute performance testing</li> </ul>"},{"location":"deployment/deployment-strategy/#3-automated-deployment","title":"3. Automated Deployment","text":"<ul> <li>Automate deployment to test environments</li> <li>Streamline Play Store submission</li> <li>Automate release notes generation</li> </ul>"},{"location":"deployment/deployment-strategy/#security-recommendations","title":"Security Recommendations","text":"<p>Based on the current implementation, the following security enhancements are recommended:</p>"},{"location":"deployment/deployment-strategy/#1-enable-code-obfuscation","title":"1. Enable Code Obfuscation","text":"<ul> <li>Enable R8 with full obfuscation</li> <li>Implement ProGuard rules to protect sensitive code</li> <li>Obfuscate class names, method names, and field names</li> </ul>"},{"location":"deployment/deployment-strategy/#2-implement-certificate-pinning","title":"2. Implement Certificate Pinning","text":"<ul> <li>Add SSL certificate pinning to prevent MITM attacks</li> <li>Verify server certificates against known good certificates</li> <li>Implement certificate rotation strategy</li> </ul>"},{"location":"deployment/deployment-strategy/#3-enhance-secure-storage","title":"3. Enhance Secure Storage","text":"<ul> <li>Use EncryptedSharedPreferences for all sensitive data</li> <li>Implement secure backup mechanisms</li> <li>Add additional encryption layers for highly sensitive data</li> </ul>"},{"location":"deployment/deployment-strategy/#4-security-monitoring","title":"4. Security Monitoring","text":"<ul> <li>Implement runtime security checks</li> <li>Add tamper detection mechanisms</li> <li>Monitor for suspicious activities</li> </ul> <p>These security measures and deployment strategies ensure that DocuSnap-Frontend is deployed in a secure, efficient manner that protects user data while providing a smooth user experience.</p>"},{"location":"deployment/deployment-topology/","title":"Production Environment Deployment Topology","text":"<p>The deployment architecture of DocuSnap-Frontend involves multiple components and environments, from development to end-user devices. The following diagram illustrates the complete deployment topology:</p> <p></p>"},{"location":"deployment/deployment-topology/#development-environment","title":"Development Environment","text":"<p>The development environment includes the following components:</p>"},{"location":"deployment/deployment-topology/#1-source-code-repository","title":"1. Source Code Repository","text":"<ul> <li>GitHub hosts the source code</li> <li>Supports version control and collaborative development</li> <li>Includes branch strategy and code review process</li> </ul>"},{"location":"deployment/deployment-topology/#2-development-tools","title":"2. Development Tools","text":"<ul> <li>Android Studio: Primary IDE</li> <li>Gradle: Build system</li> <li>Kotlin compiler: Code compilation</li> </ul>"},{"location":"deployment/deployment-topology/#3-development-process","title":"3. Development Process","text":"<ul> <li>Local development and testing</li> <li>Code commits and reviews</li> <li>Continuous integration builds</li> </ul>"},{"location":"deployment/deployment-topology/#build-process","title":"Build Process","text":"<p>The build process includes the following steps:</p>"},{"location":"deployment/deployment-topology/#1-code-compilation","title":"1. Code Compilation","text":"<ul> <li>Kotlin source code is compiled to bytecode</li> <li>Resource files are processed and optimized</li> </ul>"},{"location":"deployment/deployment-topology/#2-code-optimization","title":"2. Code Optimization","text":"<ul> <li>R8 code optimization (currently not enabled)</li> <li>Resource compression and obfuscation</li> </ul>"},{"location":"deployment/deployment-topology/#3-build-types","title":"3. Build Types","text":"<ul> <li>Debug build: Used for development and testing</li> <li>Release build: Used for distribution</li> </ul>"},{"location":"deployment/deployment-topology/#4-build-artifacts","title":"4. Build Artifacts","text":"<ul> <li>APK file: Directly installable application package</li> <li>App Bundle (AAB) not currently configured</li> </ul>"},{"location":"deployment/deployment-topology/#deployment-targets","title":"Deployment Targets","text":"<p>The application's deployment targets include:</p>"},{"location":"deployment/deployment-topology/#1-test-devices","title":"1. Test Devices","text":"<ul> <li>Development testing environment</li> <li>Internal testing and QA</li> </ul>"},{"location":"deployment/deployment-topology/#2-app-stores","title":"2. App Stores","text":"<ul> <li>Google Play Store</li> <li>Other third-party app stores</li> </ul>"},{"location":"deployment/deployment-topology/#3-user-devices","title":"3. User Devices","text":"<ul> <li>End users' Android devices</li> <li>Requires Android 13 (API 33) or higher</li> </ul>"},{"location":"deployment/deployment-topology/#external-services","title":"External Services","text":"<p>The application depends on external services including:</p>"},{"location":"deployment/deployment-topology/#1-backend-server","title":"1. Backend Server","text":"<ul> <li>Provides API services</li> <li>Processes document and form data</li> <li>Performs OCR and field extraction</li> </ul>"},{"location":"deployment/deployment-topology/#2-cloud-storage","title":"2. Cloud Storage","text":"<ul> <li>Stores processing results and user data</li> <li>Supports data backup and synchronization</li> </ul>"},{"location":"deployment/deployment-topology/#deployment-workflow","title":"Deployment Workflow","text":"<p>The typical deployment workflow follows these steps:</p> <ol> <li>Development: Developers write and test code locally</li> <li>Code Review: Changes undergo peer review</li> <li>Integration: Approved changes are merged into the main branch</li> <li>Building: CI system builds the application</li> <li>Testing: Automated and manual testing is performed</li> <li>Release Preparation: Version numbers are updated, release notes are prepared</li> <li>Distribution: Application is uploaded to app stores</li> <li>Approval: App store review process</li> <li>Release: Application is made available to users</li> <li>Monitoring: Application performance and issues are monitored</li> </ol>"},{"location":"deployment/deployment-topology/#scaling-considerations","title":"Scaling Considerations","text":"<p>The application architecture considers the following scaling aspects:</p>"},{"location":"deployment/deployment-topology/#1-user-base-scaling","title":"1. User Base Scaling","text":"<ul> <li>Local processing reduces backend load</li> <li>Efficient data synchronization minimizes network traffic</li> <li>Background processing optimizes user experience</li> </ul>"},{"location":"deployment/deployment-topology/#2-feature-scaling","title":"2. Feature Scaling","text":"<ul> <li>Modular architecture supports feature additions</li> <li>Clear interfaces between components</li> <li>Separation of concerns facilitates parallel development</li> </ul>"},{"location":"deployment/deployment-topology/#3-performance-scaling","title":"3. Performance Scaling","text":"<ul> <li>Image processing optimizations for different device capabilities</li> <li>Adaptive resource usage based on device specifications</li> <li>Configurable quality settings for different use cases</li> </ul>"},{"location":"deployment/deployment-topology/#deployment-security","title":"Deployment Security","text":"<p>The deployment process includes several security measures:</p>"},{"location":"deployment/deployment-topology/#1-code-signing","title":"1. Code Signing","text":"<ul> <li>Application is signed with developer's key</li> <li>Signature verification ensures integrity</li> </ul>"},{"location":"deployment/deployment-topology/#2-distribution-security","title":"2. Distribution Security","text":"<ul> <li>App stores provide additional security verification</li> <li>Safe distribution channels reduce risk of tampering</li> </ul>"},{"location":"deployment/deployment-topology/#3-runtime-security","title":"3. Runtime Security","text":"<ul> <li>Application operates in Android's sandbox environment</li> <li>Permissions are requested at runtime</li> <li>Sensitive operations require user confirmation</li> </ul> <p>This deployment topology ensures that DocuSnap-Frontend is developed, built, and distributed in a secure and efficient manner, providing a reliable application to end users.</p>"},{"location":"deployment/technology-dependencies/","title":"Technology Stack and Dependencies","text":"<p>DocuSnap-Frontend relies on multiple libraries and frameworks to provide its functionality. This page details the runtime and build dependencies of the application.</p>"},{"location":"deployment/technology-dependencies/#runtime-dependencies","title":"Runtime Dependencies","text":""},{"location":"deployment/technology-dependencies/#1-ui-framework","title":"1. UI Framework","text":"<ul> <li>Jetpack Compose (androidx.compose.*)</li> <li>Modern declarative UI framework</li> <li>Core components: ui-core, ui-tooling, foundation, material3</li> <li> <p>Version: Latest BOM (Bill of Materials)</p> </li> <li> <p>Material Design 3 (androidx.material3)</p> </li> <li>Implements Material Design guidelines</li> <li> <p>Provides modern UI components and theming</p> </li> <li> <p>Navigation Compose (androidx.navigation:navigation-compose)</p> </li> <li>Handles navigation between screens</li> <li>Supports deep linking and type-safe navigation</li> </ul>"},{"location":"deployment/technology-dependencies/#2-architecture-components","title":"2. Architecture Components","text":"<ul> <li>Jetpack ViewModel (androidx.lifecycle:lifecycle-viewmodel-ktx)</li> <li>Manages UI-related data through lifecycle changes</li> <li> <p>Survives configuration changes</p> </li> <li> <p>Kotlin Coroutines (org.jetbrains.kotlinx:kotlinx-coroutines-android)</p> </li> <li>Handles asynchronous operations</li> <li> <p>Provides structured concurrency</p> </li> <li> <p>Flow (part of kotlinx-coroutines)</p> </li> <li>Implements reactive programming</li> <li> <p>Supports data streaming and transformation</p> </li> <li> <p>Lifecycle Components (androidx.lifecycle:lifecycle-runtime-ktx)</p> </li> <li>Manages Android component lifecycles</li> <li>Provides lifecycle-aware components</li> </ul>"},{"location":"deployment/technology-dependencies/#3-network-communication","title":"3. Network Communication","text":"<ul> <li>Retrofit (com.squareup.retrofit2:retrofit)</li> <li>Type-safe HTTP client</li> <li> <p>Version: 2.9.0</p> </li> <li> <p>OkHttp (com.squareup.okhttp3:okhttp)</p> </li> <li>Efficient HTTP client</li> <li>Provides interceptors and caching</li> <li> <p>Version: 4.12.0</p> </li> <li> <p>Moshi and Gson (for JSON processing)</p> </li> <li>com.squareup.retrofit2:converter-gson</li> <li>com.squareup.retrofit2:converter-moshi</li> <li>Handles JSON serialization and deserialization</li> </ul>"},{"location":"deployment/technology-dependencies/#4-local-storage","title":"4. Local Storage","text":"<ul> <li>Room Database (androidx.room.*)</li> <li>Provides abstraction layer over SQLite</li> <li>Supports type-safe queries and data access</li> <li> <p>Version: 2.7.2</p> </li> <li> <p>SharedPreferences</p> </li> <li>Stores simple key-value pairs</li> <li>Used for application settings</li> </ul>"},{"location":"deployment/technology-dependencies/#5-image-processing","title":"5. Image Processing","text":"<ul> <li>CameraX (androidx.camera.*)</li> <li>Simplifies camera implementation</li> <li>Components: camera-camera2, camera-lifecycle, camera-view, camera-extensions</li> <li> <p>Version: 1.3.0</p> </li> <li> <p>Coil (io.coil-kt:coil-compose)</p> </li> <li>Image loading library</li> <li>Efficiently loads and caches images</li> <li>Version: 2.5.0</li> </ul>"},{"location":"deployment/technology-dependencies/#6-serialization","title":"6. Serialization","text":"<ul> <li>Kotlinx Serialization</li> <li>Handles object serialization and deserialization</li> <li>Used for data model serialization</li> </ul>"},{"location":"deployment/technology-dependencies/#build-dependencies","title":"Build Dependencies","text":""},{"location":"deployment/technology-dependencies/#1-build-tools","title":"1. Build Tools","text":"<ul> <li>Gradle Build System</li> <li>Manages build process and dependencies</li> <li> <p>Uses Kotlin DSL for build scripts</p> </li> <li> <p>Kotlin Gradle Plugin</p> </li> <li>Enables Kotlin compilation</li> <li> <p>Configures Kotlin compiler options</p> </li> <li> <p>Android Gradle Plugin</p> </li> <li>Provides Android-specific build capabilities</li> <li>Configures Android build process</li> </ul>"},{"location":"deployment/technology-dependencies/#2-compilation-tools","title":"2. Compilation Tools","text":"<ul> <li>Kotlin Compiler</li> <li>Compiles Kotlin source code</li> <li> <p>Supports modern language features</p> </li> <li> <p>R8 Code Optimizer</p> </li> <li>Performs code shrinking and optimization</li> <li> <p>Not currently enabled in the project</p> </li> <li> <p>Android SDK Tools</p> </li> <li>Provides Android platform tools and APIs</li> <li>Used for building Android applications</li> </ul>"},{"location":"deployment/technology-dependencies/#3-resource-processing","title":"3. Resource Processing","text":"<ul> <li>Android Resource Compiler</li> <li>Processes Android resource files</li> <li> <p>Generates R.java file</p> </li> <li> <p>Resource Optimization Tools</p> </li> <li>Optimizes drawables and other resources</li> <li>Reduces application size</li> </ul>"},{"location":"deployment/technology-dependencies/#dependency-relationship-diagram","title":"Dependency Relationship Diagram","text":"<p>The main dependency relationships in the application are as follows:</p> <pre><code>Android Runtime (ART)\n\u251c\u2500\u2500 Jetpack Compose\n\u2502   \u251c\u2500\u2500 Material Design 3\n\u2502   \u2514\u2500\u2500 Navigation Compose\n\u251c\u2500\u2500 Retrofit\n\u2502   \u2514\u2500\u2500 OkHttp\n\u251c\u2500\u2500 Room Database\n\u251c\u2500\u2500 CameraX\n\u2514\u2500\u2500 Kotlin Standard Library\n    \u251c\u2500\u2500 Coroutines\n    \u2514\u2500\u2500 Flow\n</code></pre>"},{"location":"deployment/technology-dependencies/#dependency-management","title":"Dependency Management","text":"<p>The application uses Gradle's dependency management system with the following features:</p>"},{"location":"deployment/technology-dependencies/#1-version-catalogs","title":"1. Version Catalogs","text":"<ul> <li>Centralizes dependency versions</li> <li>Simplifies version updates</li> <li>Example from build.gradle.kts:   <pre><code>implementation(platform(libs.androidx.compose.bom))\nimplementation(libs.androidx.ui)\nimplementation(libs.androidx.ui.graphics)\nimplementation(libs.androidx.material3)\n</code></pre></li> </ul>"},{"location":"deployment/technology-dependencies/#2-dependency-configurations","title":"2. Dependency Configurations","text":"<ul> <li>Uses appropriate configurations (implementation, api, etc.)</li> <li>Minimizes unnecessary transitive dependencies</li> <li>Example:   <pre><code>implementation(\"androidx.core:core-ktx:1.12.0\")\nimplementation(\"androidx.lifecycle:lifecycle-runtime-ktx:2.7.0\")\ntestImplementation(\"junit:junit:4.13.2\")\n</code></pre></li> </ul>"},{"location":"deployment/technology-dependencies/#3-dependency-constraints","title":"3. Dependency Constraints","text":"<ul> <li>Resolves version conflicts</li> <li>Enforces specific versions when needed</li> <li>Example:   <pre><code>constraints {\n    implementation(\"org.jetbrains.kotlin:kotlin-stdlib:1.9.0\")\n}\n</code></pre></li> </ul>"},{"location":"deployment/technology-dependencies/#build-configuration","title":"Build Configuration","text":"<p>The application is configured with the following build parameters:</p> <ul> <li>Compile SDK Version: 35</li> <li>Minimum SDK Version: 33 (Android 13)</li> <li>Target SDK Version: 35</li> <li>Java Compatibility Version: Java 11</li> <li>Kotlin Version: Latest stable</li> <li>Compose Compiler Version: Compatible with Kotlin version</li> </ul> <p>These dependencies and configurations ensure that DocuSnap-Frontend is built with modern, robust libraries that provide the necessary functionality while maintaining compatibility with the target Android versions.</p>"},{"location":"modules/backend-communication/","title":"Backend Communication Module","text":""},{"location":"modules/backend-communication/#responsibilities","title":"Responsibilities","text":"<p>The Backend Communication module is responsible for secure communication with the backend server, providing remote processing and data synchronization capabilities for the application. Its main responsibilities include:</p> <ul> <li>Managing API communication with the backend server</li> <li>Implementing secure data encryption and transmission</li> <li>Handling long-running backend jobs</li> <li>Managing job status and results</li> <li>Handling network errors and retry logic</li> <li>Implementing data synchronization and conflict resolution</li> </ul>"},{"location":"modules/backend-communication/#interface-design","title":"Interface Design","text":""},{"location":"modules/backend-communication/#main-classes-and-interfaces","title":"Main Classes and Interfaces","text":""},{"location":"modules/backend-communication/#1-backendapiservice","title":"1. BackendApiService","text":"<p>Manages all interactions with the backend server, handling encrypted communication and authentication.</p> <pre><code>class BackendApiService(\n    private val retrofit: Retrofit,\n    private val cryptoUtil: CryptoUtil,\n    private val settingsManager: SettingsManager\n) {\n    private val api = retrofit.create(BackendApiInterface::class.java)\n\n    // Process document\n    suspend fun processDocument(document: Document): ProcessingResult {\n        return process(\"document_process\", document)\n    }\n\n    // Process form\n    suspend fun processForm(form: Form): ProcessingResult {\n        return process(\"form_process\", form)\n    }\n\n    // Check job status\n    suspend fun checkJobStatus(jobId: String): JobStatus {\n        val requestBody = JSONObject().apply {\n            put(\"job_id\", jobId)\n        }\n\n        val response = api.checkStatus(requestBody.toString())\n        return JobStatus(\n            id = jobId,\n            status = response.getString(\"status\"),\n            progress = response.optInt(\"progress\", 0),\n            result = response.optJSONObject(\"result\")\n        )\n    }\n\n    // Generic processing function\n    private suspend fun process(\n        type: String,\n        payload: Any\n    ): ProcessingResult {\n        val innerJson = JSONObject().apply {\n            when (payload) {\n                is Document -&gt; {\n                    put(\"id\", payload.id)\n                    put(\"name\", payload.name)\n                    put(\"images\", JSONArray(payload.imageBase64s))\n                    // Other properties\n                }\n                is Form -&gt; {\n                    put(\"id\", payload.id)\n                    put(\"name\", payload.name)\n                    put(\"images\", JSONArray(payload.imageBase64s))\n                    // Other properties\n                }\n                else -&gt; throw IllegalArgumentException(\"Unsupported payload type\")\n            }\n        }\n\n        // Generate AES key\n        val aesKey = cryptoUtil.generateAesKey()\n        val encryptedContent = cryptoUtil.aesEncrypt(innerJson.toString().toByteArray(), aesKey)\n        val sha256 = cryptoUtil.computeSHA256(encryptedContent)\n        val encryptedAesKey = cryptoUtil.rsaEncrypt(aesKey, cryptoUtil.getPublicKey(settingsManager.getPublicKeyPem()))\n        val encryptedAesKeyBase64 = Base64.encodeToString(encryptedAesKey, Base64.NO_WRAP)\n\n        // Build request body\n        val requestBody = JSONObject().apply {\n            put(\"type\", type)\n            put(\"SHA256\", sha256)\n            put(\"has_content\", true)\n            put(\"aes_key\", encryptedAesKeyBase64)\n            put(\"content\", Base64.encodeToString(encryptedContent, Base64.NO_WRAP))\n        }\n\n        // Send request\n        val response = api.process(requestBody.toString())\n\n        return ProcessingResult(\n            success = response.getBoolean(\"success\"),\n            jobId = response.getString(\"job_id\"),\n            message = response.optString(\"message\", \"\")\n        )\n    }\n}\n\n// Processing result data class\ndata class ProcessingResult(\n    val success: Boolean,\n    val jobId: String,\n    val message: String\n)\n\n// Job status data class\ndata class JobStatus(\n    val id: String,\n    val status: String,\n    val progress: Int,\n    val result: JSONObject?\n)\n</code></pre>"},{"location":"modules/backend-communication/#2-jobpollingservice","title":"2. JobPollingService","text":"<p>Manages long-running backend jobs, implementing a polling mechanism to check job status.</p> <pre><code>class JobPollingService(\n    private val backendApiService: BackendApiService,\n    private val jobDao: JobDao,\n    private val cryptoUtil: CryptoUtil\n) {\n    private val coroutineScope = CoroutineScope(Dispatchers.IO + SupervisorJob())\n    private val pollingJobs = mutableMapOf&lt;String, Job&gt;()\n\n    // Start polling job status\n    fun startPolling(jobId: String) {\n        if (pollingJobs.containsKey(jobId)) return\n\n        pollingJobs[jobId] = coroutineScope.launch {\n            var retryCount = 0\n            var completed = false\n\n            while (!completed &amp;&amp; isActive) {\n                try {\n                    val job = jobDao.getJobById(jobId) ?: break\n\n                    // Check job status\n                    val status = backendApiService.checkJobStatus(jobId)\n\n                    when (status.status) {\n                        \"completed\" -&gt; {\n                            // Process completion\n                            val result = status.result?.toString()\n                            jobDao.updateJobStatus(jobId, \"completed\", result = result)\n                            completed = true\n                        }\n                        \"failed\" -&gt; {\n                            // Process failure\n                            jobDao.updateJobStatus(jobId, \"failed\", errorDetail = status.result?.optString(\"error\"))\n                            completed = true\n                        }\n                        \"processing\" -&gt; {\n                            // Processing\n                            jobDao.updateJobProgress(jobId, status.progress)\n                            retryCount = 0\n                            delay(500) // Short polling interval\n                        }\n                        else -&gt; {\n                            // Other status\n                            delay(500) // Short polling interval\n                        }\n                    }\n                } catch (e: Exception) {\n                    retryCount++\n                    val delayTime = if (retryCount &gt; 3) 5000L else 1000L // Increase interval after errors\n                    delay(delayTime)\n                }\n            }\n\n            pollingJobs.remove(jobId)\n        }\n    }\n\n    // Stop polling\n    fun stopPolling(jobId: String) {\n        pollingJobs[jobId]?.cancel()\n        pollingJobs.remove(jobId)\n    }\n\n    // Stop all polling\n    fun stopAllPolling() {\n        pollingJobs.values.forEach { it.cancel() }\n        pollingJobs.clear()\n    }\n\n    // Decrypt job result\n    fun decryptJobResult(encryptedResult: String, job: JobEntity): String {\n        // Decrypt result using the AES key created when the job was created\n        val encryptedBytes = Base64.decode(encryptedResult, Base64.NO_WRAP)\n        val aesKey = job.aesKey?.let { Base64.decode(it, Base64.NO_WRAP) }\n            ?: throw IllegalStateException(\"Missing AES key for job ${job.id}\")\n\n        return String(cryptoUtil.aesDecrypt(encryptedBytes, aesKey))\n    }\n}\n</code></pre>"},{"location":"modules/backend-communication/#design-patterns-and-extension-points","title":"Design Patterns and Extension Points","text":""},{"location":"modules/backend-communication/#design-patterns","title":"Design Patterns","text":""},{"location":"modules/backend-communication/#1-adapter-pattern","title":"1. Adapter Pattern","text":"<ul> <li>Adapts REST API through Retrofit interface</li> <li>Converts HTTP requests to local method calls</li> </ul>"},{"location":"modules/backend-communication/#2-observer-pattern","title":"2. Observer Pattern","text":"<ul> <li>Uses Flow to monitor job status changes</li> <li>Automatically updates UI in response to status changes</li> </ul>"},{"location":"modules/backend-communication/#3-decorator-pattern","title":"3. Decorator Pattern","text":"<ul> <li>Decorates original data with encryption</li> <li>Enhances security without changing the interface</li> </ul>"},{"location":"modules/backend-communication/#4-asynchronous-job-pattern","title":"4. Asynchronous Job Pattern","text":"<ul> <li>Long-running tasks are processed as asynchronous jobs</li> <li>Job status is tracked through a polling mechanism</li> </ul>"},{"location":"modules/backend-communication/#extension-points","title":"Extension Points","text":""},{"location":"modules/backend-communication/#1-encryption-algorithm-replacement","title":"1. Encryption Algorithm Replacement","text":"<ul> <li>Encryption algorithms can be replaced or upgraded</li> <li>Supports different key management strategies</li> </ul>"},{"location":"modules/backend-communication/#2-communication-protocol-upgrade","title":"2. Communication Protocol Upgrade","text":"<ul> <li>Can be upgraded to WebSocket or other real-time communication</li> <li>Supports different API versions</li> </ul>"},{"location":"modules/backend-communication/#3-authentication-mechanism-extension","title":"3. Authentication Mechanism Extension","text":"<ul> <li>Can be extended to OAuth or other authentication methods</li> <li>Supports multiple authentication strategies</li> </ul>"},{"location":"modules/backend-communication/#4-offline-operation-support","title":"4. Offline Operation Support","text":"<ul> <li>Can be extended to support offline queuing and synchronization</li> <li>Implements more complex conflict resolution strategies</li> </ul>"},{"location":"modules/backend-communication/#security-implementation","title":"Security Implementation","text":"<p>The Backend Communication module implements a robust security system:</p> <ol> <li>Hybrid Encryption:</li> <li>RSA encryption (2048-bit) for key exchange</li> <li>AES-CBC encryption (256-bit) for content</li> <li> <p>Each request uses a unique AES key</p> </li> <li> <p>Data Integrity:</p> </li> <li>SHA-256 hash verification ensures data integrity</li> <li> <p>Prevents data tampering during transmission</p> </li> <li> <p>Secure Transport:</p> </li> <li>All communication occurs over HTTPS</li> <li> <p>Certificate validation prevents man-in-the-middle attacks</p> </li> <li> <p>Error Handling:</p> </li> <li>Graceful handling of network errors</li> <li>Automatic retries with exponential backoff</li> <li>Detailed error reporting for debugging</li> </ol> <p>This comprehensive security approach ensures that sensitive document and form data is protected during transmission and processing.</p>"},{"location":"modules/document-processing/","title":"Document Processing Module","text":""},{"location":"modules/document-processing/#responsibilities","title":"Responsibilities","text":"<p>The Document Processing module is responsible for document capture, processing, and management, which is one of the core functional modules of the application. Its main responsibilities include:</p> <ul> <li>Document data model definition and management</li> <li>Document creation, reading, updating, and deletion (CRUD) operations</li> <li>Document metadata extraction and management</li> <li>Document search and filtering</li> <li>Document usage statistics tracking</li> <li>Document relationship management</li> </ul>"},{"location":"modules/document-processing/#interface-design","title":"Interface Design","text":""},{"location":"modules/document-processing/#main-classes-and-interfaces","title":"Main Classes and Interfaces","text":""},{"location":"modules/document-processing/#1-documentviewmodel","title":"1. DocumentViewModel","text":"<p>Manages document states and operations, providing document loading, saving, updating, and deletion functions, as well as managing document search and usage statistics.</p> <pre><code>class DocumentViewModel(private val repository: DocumentRepository) : ViewModel() {\n    // Document list state\n    private val _documents = MutableStateFlow&lt;List&lt;Document&gt;&gt;(emptyList())\n    val documents: StateFlow&lt;List&lt;Document&gt;&gt; = _documents.asStateFlow()\n\n    // Loading state\n    private val _isLoading = MutableStateFlow(false)\n    val isLoading: StateFlow&lt;Boolean&gt; = _isLoading.asStateFlow()\n\n    // Load all documents\n    fun loadDocuments() {\n        viewModelScope.launch {\n            _isLoading.value = true\n            try {\n                val docs = repository.getAllDocuments()\n                _documents.value = docs\n            } catch (e: Exception) {\n                // Error handling\n            } finally {\n                _isLoading.value = false\n            }\n        }\n    }\n\n    // Get a single document\n    suspend fun getDocument(id: String): Document? {\n        return repository.getDocument(id)\n    }\n\n    // Save document\n    suspend fun saveDocument(document: Document) {\n        repository.saveDocument(document)\n        loadDocuments() // Refresh list\n    }\n\n    // Update document\n    suspend fun updateDocument(document: Document) {\n        repository.updateDocument(document)\n        loadDocuments() // Refresh list\n    }\n\n    // Delete document\n    suspend fun deleteDocument(id: String) {\n        repository.deleteDocument(id)\n        loadDocuments() // Refresh list\n    }\n\n    // Update extracted info usage statistics\n    suspend fun updateExtractedInfoUsage(fileId: String, fileType: FileType, key: String) {\n        repository.updateExtractedInfoUsage(fileId, fileType, key)\n    }\n}\n</code></pre>"},{"location":"modules/document-processing/#2-documentrepository","title":"2. DocumentRepository","text":"<p>Abstracts document data access, coordinates data flow between local database and remote API, and handles document serialization and deserialization.</p> <pre><code>class DocumentRepository(private val deviceDBService: DeviceDBService) {\n    // Get all documents\n    suspend fun getAllDocuments(): List&lt;Document&gt; {\n        return deviceDBService.getDocumentGallery().mapNotNull { json -&gt;\n            try {\n                Document(\n                    id = json.getString(\"id\"),\n                    name = json.getString(\"name\"),\n                    // Other property mapping\n                )\n            } catch (e: Exception) {\n                null\n            }\n        }\n    }\n\n    // Get a single document\n    suspend fun getDocument(id: String): Document? {\n        val json = deviceDBService.getDocument(id) ?: return null\n        return try {\n            Document(\n                id = json.getString(\"id\"),\n                name = json.getString(\"name\"),\n                // Other property mapping\n            )\n        } catch (e: Exception) {\n            null\n        }\n    }\n\n    // Save document\n    suspend fun saveDocument(document: Document) {\n        val json = JSONObject().apply {\n            put(\"id\", document.id)\n            put(\"name\", document.name)\n            // Other property mapping\n        }\n        deviceDBService.saveDocument(json)\n    }\n\n    // Update document\n    suspend fun updateDocument(document: Document) {\n        saveDocument(document) // Simplified implementation, could be optimized\n    }\n\n    // Delete document\n    suspend fun deleteDocument(id: String) {\n        deviceDBService.deleteDocument(id)\n    }\n\n    // Update extracted info usage statistics\n    suspend fun updateExtractedInfoUsage(fileId: String, fileType: FileType, key: String) {\n        deviceDBService.updateExtractedInfoUsage(fileId, fileType, key)\n    }\n}\n</code></pre>"},{"location":"modules/document-processing/#3-devicedbservice","title":"3. DeviceDBService","text":"<p>Local data storage service that uses Room database to store document entities and manages document CRUD operations.</p>"},{"location":"modules/document-processing/#4-document-data-model","title":"4. Document Data Model","text":"<p>Represents the core data structure for documents.</p> <pre><code>@Serializable\ndata class Document(\n    val id: String,\n    val name: String,\n    val description: String,\n    val imageBase64s: List&lt;String&gt; = emptyList(),\n    val extractedInfo: List&lt;ExtractedInfoItem&gt; = emptyList(),\n    val tags: List&lt;String&gt; = emptyList(),\n    val uploadDate: String = \"2024-01-15\",\n    val relatedFileIds: List&lt;String&gt; = emptyList(),\n    val sha256: String? = null,\n    val isProcessed: Boolean = false,\n    val jobId: Long? = null,\n    val usageCount: Int = 0,\n    val lastUsed: String = \"2024-01-15\"\n)\n</code></pre>"},{"location":"modules/document-processing/#design-patterns-and-extension-points","title":"Design Patterns and Extension Points","text":""},{"location":"modules/document-processing/#design-patterns","title":"Design Patterns","text":""},{"location":"modules/document-processing/#1-repository-pattern","title":"1. Repository Pattern","text":"<ul> <li>Abstracts data access logic</li> <li>Provides a unified data interface</li> <li>Hides data source details</li> </ul>"},{"location":"modules/document-processing/#2-observer-pattern","title":"2. Observer Pattern","text":"<ul> <li>Uses StateFlow to implement reactive data flow</li> <li>Automatically updates UI in response to data changes</li> </ul>"},{"location":"modules/document-processing/#3-factory-pattern","title":"3. Factory Pattern","text":"<ul> <li>Uses ViewModelFactory to create ViewModel instances</li> <li>Supports dependency injection</li> </ul>"},{"location":"modules/document-processing/#extension-points","title":"Extension Points","text":""},{"location":"modules/document-processing/#1-custom-metadata-extraction","title":"1. Custom Metadata Extraction","text":"<ul> <li>The <code>extractedInfo</code> field supports custom metadata</li> <li>Extraction algorithms and field types can be extended</li> </ul>"},{"location":"modules/document-processing/#2-document-relationships","title":"2. Document Relationships","text":"<ul> <li><code>relatedFileIds</code> allows establishing relationships between documents</li> <li>Can be extended to more complex relationship graphs</li> </ul>"},{"location":"modules/document-processing/#3-document-processing-plugins","title":"3. Document Processing Plugins","text":"<ul> <li>Backend processing capabilities can be extended</li> <li>Supports new document types and processing algorithms</li> </ul>"},{"location":"modules/document-processing/#4-usage-statistics-and-analysis","title":"4. Usage Statistics and Analysis","text":"<ul> <li>Existing usage statistics mechanism can be extended to more complex analytics</li> <li>Supports personalized recommendations and intelligent sorting</li> </ul>"},{"location":"modules/form-processing/","title":"Form Processing Module","text":""},{"location":"modules/form-processing/#responsibilities","title":"Responsibilities","text":"<p>The Form Processing module focuses on form capture, field extraction, and management, which is another core functional module of the application. Its main responsibilities include:</p> <ul> <li>Form data model definition and management</li> <li>Automatic recognition and extraction of form fields</li> <li>Form creation, reading, updating, and deletion operations</li> <li>Form field editing and validation</li> <li>Form template management</li> <li>Form data export and sharing</li> </ul>"},{"location":"modules/form-processing/#interface-design","title":"Interface Design","text":""},{"location":"modules/form-processing/#main-classes-and-interfaces","title":"Main Classes and Interfaces","text":""},{"location":"modules/form-processing/#1-form-data-model","title":"1. Form Data Model","text":"<p>Defines the data structure and fields of a form.</p> <pre><code>@Serializable\ndata class Form(\n    val id: String,\n    val name: String,\n    val description: String,\n    val imageBase64s: List&lt;String&gt; = emptyList(),\n    val formFields: List&lt;FormField&gt; = emptyList(),\n    val extractedInfo: List&lt;ExtractedInfoItem&gt; = emptyList(),\n    val tags: List&lt;String&gt; = emptyList(),\n    val uploadDate: String = \"2024-01-15\",\n    val relatedFileIds: List&lt;String&gt; = emptyList(),\n    val sha256: String? = null,\n    val isProcessed: Boolean = false,\n    val jobId: Long? = null,\n    val usageCount: Int = 0,\n    val lastUsed: String = \"2024-01-15\"\n)\n</code></pre>"},{"location":"modules/form-processing/#2-form-field-model","title":"2. Form Field Model","text":"<p>Represents a single field in a form.</p> <pre><code>@Serializable\ndata class FormField(\n    val name: String,\n    val value: String? = null,\n    val isRetrieved: Boolean = false,\n    val srcFileId: String? = null\n)\n</code></pre>"},{"location":"modules/form-processing/#3-formdao","title":"3. FormDao","text":"<p>Provides interface for form database operations, supporting form search and filtering.</p> <pre><code>@Dao\ninterface FormDao {\n    @Query(\"SELECT * FROM forms ORDER BY last_used DESC\")\n    fun getAll(): Flow&lt;List&lt;FormEntity&gt;&gt;\n\n    @Query(\"SELECT * FROM forms WHERE id = :id\")\n    suspend fun getById(id: String): FormEntity?\n\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insert(form: FormEntity)\n\n    @Update\n    suspend fun update(form: FormEntity)\n\n    @Delete\n    suspend fun delete(form: FormEntity)\n\n    @Query(\"SELECT * FROM forms WHERE name LIKE '%' || :query || '%' OR description LIKE '%' || :query || '%'\")\n    fun search(query: String): Flow&lt;List&lt;FormEntity&gt;&gt;\n}\n</code></pre>"},{"location":"modules/form-processing/#design-patterns-and-extension-points","title":"Design Patterns and Extension Points","text":""},{"location":"modules/form-processing/#design-patterns","title":"Design Patterns","text":""},{"location":"modules/form-processing/#1-data-mapping-pattern","title":"1. Data Mapping Pattern","text":"<ul> <li>Converts between entities and models</li> <li>Separates persistence logic from business logic</li> </ul>"},{"location":"modules/form-processing/#2-strategy-pattern","title":"2. Strategy Pattern","text":"<ul> <li>Different field extraction strategies can be interchanged</li> <li>Supports processing of different form types</li> </ul>"},{"location":"modules/form-processing/#3-observer-pattern","title":"3. Observer Pattern","text":"<ul> <li>Uses Flow to implement reactive data flow</li> <li>Automatically updates UI in response to data changes</li> </ul>"},{"location":"modules/form-processing/#extension-points","title":"Extension Points","text":""},{"location":"modules/form-processing/#1-custom-form-templates","title":"1. Custom Form Templates","text":"<ul> <li>Form templates can be defined and applied</li> <li>Supports specialized templates for different industries and scenarios</li> </ul>"},{"location":"modules/form-processing/#2-field-validation-rules","title":"2. Field Validation Rules","text":"<ul> <li>Field validation logic can be extended</li> <li>Supports custom validation rules and error messages</li> </ul>"},{"location":"modules/form-processing/#3-form-data-export-formats","title":"3. Form Data Export Formats","text":"<ul> <li>Can be extended to multiple export formats</li> <li>Supports integration with other systems</li> </ul>"},{"location":"modules/form-processing/#4-intelligent-field-matching","title":"4. Intelligent Field Matching","text":"<ul> <li>Field recognition algorithms can be extended</li> <li>Supports machine learning-based field recognition</li> </ul>"},{"location":"modules/form-processing/#form-processing-workflow","title":"Form Processing Workflow","text":"<p>The form processing workflow involves several steps:</p> <ol> <li>Form Capture: User captures form images using the camera or selects from the media library</li> <li>Image Processing: Images are processed to enhance quality and readability</li> <li>Field Extraction: Form is sent to the backend for field extraction</li> <li>User Verification: User reviews and edits extracted fields</li> <li>Form Storage: Completed form is stored in the local database</li> <li>Form Usage: Form data can be exported, shared, or used in other applications</li> </ol> <p>This workflow combines automated processing with user interaction to provide an efficient and accurate form data capture and management solution.</p>"},{"location":"modules/image-processing/","title":"Image Processing Module","text":""},{"location":"modules/image-processing/#responsibilities","title":"Responsibilities","text":"<p>The Image Processing module is responsible for image capture and processing, providing fundamental support for document and form processing. Its main responsibilities include:</p> <ul> <li>Camera interface and image capture</li> <li>Image cropping and adjustment</li> <li>Image enhancement and filter application</li> <li>Edge detection and perspective correction</li> <li>Image quality optimization</li> <li>Image format conversion and compression</li> </ul>"},{"location":"modules/image-processing/#interface-design","title":"Interface Design","text":""},{"location":"modules/image-processing/#main-classes-and-interfaces","title":"Main Classes and Interfaces","text":""},{"location":"modules/image-processing/#1-imageprocessingviewmodel","title":"1. ImageProcessingViewModel","text":"<p>Manages image processing states and operations, coordinating different image processing functions.</p> <pre><code>class ImageProcessingViewModel(\n    private val imageProcService: ImageProcService\n) : ViewModel() {\n    // UI state\n    private val _uiState = MutableStateFlow(ImageProcessingUiState())\n    val uiState: StateFlow&lt;ImageProcessingUiState&gt; = _uiState.asStateFlow()\n\n    // Load images\n    fun loadImages(uris: List&lt;String&gt;) {\n        viewModelScope.launch {\n            _uiState.update { it.copy(\n                isLoading = true,\n                originalImageUris = uris,\n                currentImageIndex = 0\n            )}\n\n            try {\n                if (uris.isNotEmpty()) {\n                    val bitmap = loadBitmapFromUri(uris[0])\n                    _uiState.update { it.copy(\n                        editingBitmap = bitmap,\n                        isLoading = false\n                    )}\n                    detectDocumentCorners()\n                }\n            } catch (e: Exception) {\n                _uiState.update { it.copy(isLoading = false) }\n                // Error handling\n            }\n        }\n    }\n\n    // Apply binarization filter\n    fun applyBinarizationFilter() {\n        applyFilter(\"Black &amp; White\") { bitmap -&gt;\n            imageProcService.applyThresholdFilter(bitmap, 4)\n        }\n    }\n\n    // Apply high contrast filter\n    fun applyHighContrastFilter() {\n        applyFilter(\"High Contrast\") { bitmap -&gt;\n            imageProcService.applyHighContrast(bitmap)\n        }\n    }\n\n    // Detect document corners\n    fun detectDocumentCorners() {\n        viewModelScope.launch {\n            val bitmap = _uiState.value.editingBitmap ?: return@launch\n            _uiState.update { it.copy(isLoading = true) }\n\n            try {\n                val corners = imageProcService.detectDocumentCorners(bitmap)\n                _uiState.update { it.copy(\n                    detectedCorners = corners,\n                    adjustedCorners = corners.clone(),\n                    isLoading = false\n                )}\n            } catch (e: Exception) {\n                _uiState.update { it.copy(isLoading = false) }\n                // Error handling\n            }\n        }\n    }\n\n    // Apply perspective correction\n    fun applyPerspectiveCorrection() {\n        viewModelScope.launch {\n            val bitmap = _uiState.value.editingBitmap ?: return@launch\n            val corners = _uiState.value.adjustedCorners ?: return@launch\n\n            _uiState.update { it.copy(isLoading = true) }\n\n            try {\n                val correctedBitmap = imageProcService.applyPerspectiveTransform(bitmap, corners)\n                _uiState.update { it.copy(\n                    editingBitmap = correctedBitmap,\n                    isCornerAdjustmentMode = false,\n                    detectedCorners = null,\n                    adjustedCorners = null,\n                    isLoading = false\n                )}\n            } catch (e: Exception) {\n                _uiState.update { it.copy(isLoading = false) }\n                // Error handling\n            }\n        }\n    }\n\n    // Generic filter application function\n    private fun applyFilter(filterName: String, filter: suspend (Bitmap) -&gt; Bitmap) {\n        viewModelScope.launch {\n            val bitmap = _uiState.value.editingBitmap ?: return@launch\n            _uiState.update { it.copy(isLoading = true) }\n\n            try {\n                val filteredBitmap = filter(bitmap)\n                _uiState.update { it.copy(\n                    editingBitmap = filteredBitmap,\n                    appliedFilter = filterName,\n                    isLoading = false\n                )}\n            } catch (e: Exception) {\n                _uiState.update { it.copy(isLoading = false) }\n                // Error handling\n            }\n        }\n    }\n}\n\n// UI state data class\ndata class ImageProcessingUiState(\n    val isLoading: Boolean = false,\n    val originalImageUris: List&lt;String&gt; = emptyList(),\n    val currentImageIndex: Int = 0,\n    val editingBitmap: Bitmap? = null,\n    val isFilterToolbarVisible: Boolean = false,\n    val isPerspectiveToolbarVisible: Boolean = false,\n    val appliedFilter: String? = null,\n    val isCornerAdjustmentMode: Boolean = false,\n    val detectedCorners: Array&lt;PointF&gt;? = null,\n    val adjustedCorners: Array&lt;PointF&gt;? = null\n)\n</code></pre>"},{"location":"modules/image-processing/#2-imageprocservice","title":"2. ImageProcService","text":"<p>Provides low-level image processing algorithms, implementing edge detection, perspective correction, and other functions.</p> <pre><code>class ImageProcService {\n    // Apply threshold filter (binarization)\n    fun applyThresholdFilter(bitmap: Bitmap, type: Int): Bitmap {\n        val result = Bitmap.createBitmap(bitmap.width, bitmap.height, bitmap.config)\n        val threshold = when (type) {\n            1 -&gt; 100\n            2 -&gt; 127\n            3 -&gt; 150\n            else -&gt; 127\n        }\n\n        // Binarization processing\n        for (x in 0 until bitmap.width) {\n            for (y in 0 until bitmap.height) {\n                val pixel = bitmap.getPixel(x, y)\n                val gray = (Color.red(pixel) + Color.green(pixel) + Color.blue(pixel)) / 3\n                val newPixel = if (gray &gt; threshold) Color.WHITE else Color.BLACK\n                result.setPixel(x, y, newPixel)\n            }\n        }\n\n        return result\n    }\n\n    // Apply high contrast filter\n    fun applyHighContrast(bitmap: Bitmap): Bitmap {\n        val result = Bitmap.createBitmap(bitmap.width, bitmap.height, bitmap.config)\n        val canvas = Canvas(result)\n        val paint = Paint()\n        val colorMatrix = ColorMatrix()\n\n        // Increase contrast\n        colorMatrix.set(floatArrayOf(\n            2.0f, 0f, 0f, 0f, -128f,\n            0f, 2.0f, 0f, 0f, -128f,\n            0f, 0f, 2.0f, 0f, -128f,\n            0f, 0f, 0f, 1f, 0f\n        ))\n\n        paint.colorFilter = ColorMatrixColorFilter(colorMatrix)\n        canvas.drawBitmap(bitmap, 0f, 0f, paint)\n\n        return result\n    }\n\n    // Detect document corners\n    fun detectDocumentCorners(bitmap: Bitmap): Array&lt;PointF&gt; {\n        // Edge detection algorithm implementation\n        // 1. Convert to grayscale\n        // 2. Apply Gaussian blur\n        // 3. Apply Canny edge detection\n        // 4. Find contours\n        // 5. Approximate polygons\n        // 6. Find the largest quadrilateral\n\n        // Simplified implementation, returns default corners\n        return arrayOf(\n            PointF(0f, 0f),\n            PointF(bitmap.width.toFloat(), 0f),\n            PointF(bitmap.width.toFloat(), bitmap.height.toFloat()),\n            PointF(0f, bitmap.height.toFloat())\n        )\n    }\n\n    // Apply perspective transform\n    fun applyPerspectiveTransform(bitmap: Bitmap, corners: Array&lt;PointF&gt;): Bitmap {\n        // Perspective transform algorithm implementation\n        // 1. Calculate target rectangle\n        // 2. Create transformation matrix\n        // 3. Apply transformation\n\n        // Simplified implementation, returns original image\n        return bitmap.copy(bitmap.config, true)\n    }\n}\n</code></pre>"},{"location":"modules/image-processing/#3-cameracapturescreen","title":"3. CameraCaptureScreen","text":"<p>Provides camera interface, handling image capture and preview.</p>"},{"location":"modules/image-processing/#design-patterns-and-extension-points","title":"Design Patterns and Extension Points","text":""},{"location":"modules/image-processing/#design-patterns","title":"Design Patterns","text":""},{"location":"modules/image-processing/#1-strategy-pattern","title":"1. Strategy Pattern","text":"<ul> <li>Different image processing algorithms are encapsulated as independent strategies</li> <li>Strategy switching is implemented through the high-order function <code>applyFilter</code></li> </ul>"},{"location":"modules/image-processing/#2-command-pattern","title":"2. Command Pattern","text":"<ul> <li>Image processing operations are encapsulated as independent commands</li> <li>Supports operation history and undo functionality</li> </ul>"},{"location":"modules/image-processing/#3-state-pattern","title":"3. State Pattern","text":"<ul> <li>Uses <code>ImageProcessingUiState</code> to manage complex UI states</li> <li>Different operations are enabled in different states</li> </ul>"},{"location":"modules/image-processing/#extension-points","title":"Extension Points","text":""},{"location":"modules/image-processing/#1-custom-filters","title":"1. Custom Filters","text":"<ul> <li>New image processing algorithms can be extended</li> <li>Supports custom filter parameters</li> </ul>"},{"location":"modules/image-processing/#2-edge-detection-algorithms","title":"2. Edge Detection Algorithms","text":"<ul> <li>Edge detection algorithms can be replaced or enhanced</li> <li>Supports optimization for different scenarios</li> </ul>"},{"location":"modules/image-processing/#3-image-analysis-plugins","title":"3. Image Analysis Plugins","text":"<ul> <li>New image analysis functions can be added</li> <li>Supports domain-specific image processing requirements</li> </ul>"},{"location":"modules/image-processing/#4-camera-control-extensions","title":"4. Camera Control Extensions","text":"<ul> <li>Camera functions and control options can be extended</li> <li>Supports advanced shooting modes</li> </ul>"},{"location":"modules/image-processing/#image-processing-workflow","title":"Image Processing Workflow","text":"<p>The image processing workflow typically involves these steps:</p> <ol> <li>Image Capture: User captures an image using the camera or selects from the gallery</li> <li>Initial Processing: Basic processing like rotation and cropping</li> <li>Edge Detection: Automatic detection of document edges</li> <li>Perspective Correction: Correction of perspective distortion</li> <li>Enhancement: Application of filters to enhance readability</li> <li>Final Processing: Final adjustments before saving or further processing</li> </ol> <p>This workflow ensures that captured images are optimized for document and form processing, improving the accuracy of subsequent text extraction and field recognition.</p>"},{"location":"modules/module-interactions/","title":"Module Interactions","text":"<p>The core modules of DocuSnap-Frontend have complex interactions with each other. This page describes these relationships and how the modules work together to provide the application's functionality.</p>"},{"location":"modules/module-interactions/#module-relationship-diagram","title":"Module Relationship Diagram","text":""},{"location":"modules/module-interactions/#key-interaction-relationships","title":"Key Interaction Relationships","text":""},{"location":"modules/module-interactions/#1-document-processing-module-and-image-processing-module","title":"1. Document Processing Module and Image Processing Module","text":"<ul> <li>Image data is passed from the Image Processing module to the Document Processing module after processing</li> <li><code>ImageProcessingViewModel</code> updates <code>DocumentViewModel</code> after image processing is complete</li> <li>Both modules share common image handling utilities and services</li> <li>Document processing depends on image quality improvements from the image processing module</li> </ul>"},{"location":"modules/module-interactions/#2-document-processing-module-and-backend-communication-module","title":"2. Document Processing Module and Backend Communication Module","text":"<ul> <li>Document processing requires backend services for OCR and text extraction</li> <li><code>DocumentRepository</code> calls <code>BackendApiService</code> to send processing requests</li> <li><code>JobPollingService</code> retrieves processing results and updates <code>DocumentRepository</code></li> <li>The document module relies on secure communication provided by the backend module</li> </ul>"},{"location":"modules/module-interactions/#3-form-processing-module-and-image-processing-module","title":"3. Form Processing Module and Image Processing Module","text":"<ul> <li>Form capture and processing depend on the Image Processing module</li> <li>Both modules share the same image processing workflows and algorithms</li> <li>Form processing uses enhanced images from the image processing module for better field extraction</li> <li>Both modules use the camera interface provided by the image processing module</li> </ul>"},{"location":"modules/module-interactions/#4-form-processing-module-and-backend-communication-module","title":"4. Form Processing Module and Backend Communication Module","text":"<ul> <li>Form field extraction requires backend service support</li> <li>Processing results are retrieved through the same job polling mechanism</li> <li>Form data is securely transmitted using the encryption mechanisms of the backend communication module</li> <li>Form processing status is tracked through the job management system</li> </ul>"},{"location":"modules/module-interactions/#5-shared-components-and-core-modules","title":"5. Shared Components and Core Modules","text":"<ul> <li><code>CryptoUtil</code>: Provides encryption functionality used by the Backend Communication module</li> <li><code>SettingsManager</code>: Manages application settings affecting the behavior of multiple modules</li> <li><code>AppDatabase</code>: Provides data storage shared by all modules</li> <li>Common utilities and extensions are used across all modules</li> </ul>"},{"location":"modules/module-interactions/#data-flow-between-modules","title":"Data Flow Between Modules","text":"<p>The data flow between modules typically follows these patterns:</p> <ol> <li>Image Capture to Document/Form Creation:</li> <li>Camera interface (Image Processing) \u2192 Image processing \u2192 Document/Form creation</li> <li> <p>Image data flows from the Image Processing module to either the Document or Form Processing module</p> </li> <li> <p>Document/Form Processing:</p> </li> <li>Document/Form data \u2192 Backend Communication \u2192 Backend processing \u2192 Results retrieval</li> <li> <p>Processed data flows back to the Document/Form Processing module</p> </li> <li> <p>User Interaction Flow:</p> </li> <li>UI events \u2192 ViewModel processing \u2192 Repository operations \u2192 Data updates</li> <li>Updated data flows back through the ViewModel to the UI</li> </ol>"},{"location":"modules/module-interactions/#benefits-of-modular-design","title":"Benefits of Modular Design","text":"<p>The modular design of DocuSnap-Frontend offers several advantages:</p> <ul> <li>Separation of Concerns: Each module focuses on specific functionality</li> <li>Clear Communication Interfaces: Modules communicate through well-defined interfaces</li> <li>Team Collaboration: Facilitates development by different team members</li> <li>Independent Evolution: Modules can evolve independently</li> <li>Testability: Modules can be tested in isolation</li> <li>Reusability: Components can be reused across different parts of the application</li> </ul> <p>This modular architecture ensures that the application is maintainable, extensible, and robust, while allowing for efficient development and testing.</p>"},{"location":"overview/business-background/","title":"Business Background and Target Users","text":""},{"location":"overview/business-background/#business-background","title":"Business Background","text":"<p>DocuSnap-Frontend is an Android-based document scanning and form processing application designed to provide users with an efficient and secure mobile document management solution. The application leverages modern Android development architecture and technology stack to implement core features such as document capture, processing, management, and form field extraction.</p>"},{"location":"overview/business-background/#target-users","title":"Target Users","text":"<p>The application is designed to serve the following user groups:</p> <ul> <li>Business Professionals: Users who need to process documents anytime and anywhere</li> <li>Enterprise Users: Users who need to quickly process form data</li> <li>Individual Users: Users who need efficient document management</li> <li>Professional Users: Users with high security requirements for document handling</li> </ul>"},{"location":"overview/business-background/#application-value","title":"Application Value","text":"<p>DocuSnap-Frontend provides the following key values to its users:</p> <ul> <li>Improves document processing efficiency, saving time and labor costs</li> <li>Reduces manual data entry errors, improving data accuracy</li> <li>Enables document access and processing anytime and anywhere</li> <li>Protects sensitive document data security</li> <li>Simplifies form processing workflow, enhancing user experience</li> </ul>"},{"location":"overview/core-features/","title":"Core Features and Value","text":"<p>DocuSnap-Frontend provides a comprehensive set of features for document and form management, focusing on efficiency, accuracy, and security.</p>"},{"location":"overview/core-features/#core-features","title":"Core Features","text":""},{"location":"overview/core-features/#1-document-scanning-and-processing","title":"1. Document Scanning and Processing","text":"<ul> <li>High-quality image capture</li> <li>Intelligent edge detection and perspective correction</li> <li>Image enhancement and optimization</li> <li>Document classification and tag management</li> </ul>"},{"location":"overview/core-features/#2-automatic-form-field-extraction","title":"2. Automatic Form Field Extraction","text":"<ul> <li>OCR text recognition</li> <li>Intelligent field recognition and classification</li> <li>Form template matching</li> <li>User editing and confirmation</li> </ul>"},{"location":"overview/core-features/#3-image-processing-and-optimization","title":"3. Image Processing and Optimization","text":"<ul> <li>Multiple image filters</li> <li>Edge detection and perspective correction</li> <li>Contrast and brightness adjustment</li> <li>Image cropping and rotation</li> </ul>"},{"location":"overview/core-features/#4-document-and-form-management","title":"4. Document and Form Management","text":"<ul> <li>Classification and tag organization</li> <li>Full-text search</li> <li>Usage frequency statistics</li> <li>Document relationship management</li> </ul>"},{"location":"overview/core-features/#5-secure-communication-and-data-protection","title":"5. Secure Communication and Data Protection","text":"<ul> <li>End-to-end encryption</li> <li>PIN code protection</li> <li>Data integrity verification</li> <li>Secure export and sharing</li> </ul>"},{"location":"overview/core-features/#application-value","title":"Application Value","text":"<p>The DocuSnap-Frontend application delivers significant value to its users:</p> <ul> <li>Improved Efficiency: Streamlines document processing workflows, saving time and reducing manual effort</li> <li>Enhanced Accuracy: Reduces manual data entry errors through automated field extraction and recognition</li> <li>Mobility: Enables document access and processing anytime, anywhere</li> <li>Data Security: Implements robust security measures to protect sensitive document data</li> <li>User Experience: Simplifies form processing workflows with an intuitive, user-friendly interface</li> </ul> <p>These features and benefits make DocuSnap-Frontend a powerful tool for individuals and organizations that need to efficiently manage documents and forms while maintaining high levels of security and accuracy.</p>"},{"location":"processes/document-scanning/","title":"Document Scanning and Processing Flow","text":"<p>Document scanning and processing is one of the core functionalities of DocuSnap-Frontend. This process involves multiple modules and components working together. The following diagram illustrates the complete flow from image capture to document storage:</p> <p></p>"},{"location":"processes/document-scanning/#detailed-document-scanning-process","title":"Detailed Document Scanning Process","text":""},{"location":"processes/document-scanning/#1-image-capture-phase","title":"1. Image Capture Phase","text":"<ul> <li>User captures document images through the <code>CameraCaptureScreen</code></li> <li>Image data is passed to the <code>ImageProcessingScreen</code></li> <li>The camera interface uses CameraX API to ensure consistent camera experience across devices</li> <li>Users can also select images from the device gallery as an alternative</li> </ul>"},{"location":"processes/document-scanning/#2-image-processing-phase","title":"2. Image Processing Phase","text":"<ul> <li><code>ImageProcessingScreen</code> calls <code>ImageProcessingViewModel</code> to process the image</li> <li><code>ImageProcessingViewModel</code> uses <code>ImageProcService</code> to apply edge detection, perspective correction, and image enhancement</li> <li>Users can adjust processing parameters and apply filters</li> <li>Processed images are passed to the <code>DocumentDetailScreen</code></li> </ul>"},{"location":"processes/document-scanning/#3-document-creation-phase","title":"3. Document Creation Phase","text":"<ul> <li><code>DocumentDetailScreen</code> calls <code>DocumentViewModel</code> to create a document object</li> <li>User inputs document name, description, and tags</li> <li><code>DocumentViewModel</code> calls <code>DocumentRepository</code> to save the document</li> <li>Document metadata is collected and associated with the processed images</li> </ul>"},{"location":"processes/document-scanning/#4-local-storage-phase","title":"4. Local Storage Phase","text":"<ul> <li><code>DocumentRepository</code> calls <code>DeviceDBService</code> to store the document in the local database</li> <li><code>DeviceDBService</code> uses Room DAO to perform database operations</li> <li>Document is stored with its metadata and processed images</li> <li>Local storage ensures offline access to documents</li> </ul>"},{"location":"processes/document-scanning/#5-backend-processing-phase","title":"5. Backend Processing Phase","text":"<ul> <li><code>DocumentRepository</code> calls <code>BackendApiService</code> to send the document to the backend for processing</li> <li><code>BackendApiService</code> encrypts document data and sends an API request</li> <li>Backend returns a job ID, and <code>BackendApiService</code> creates a job record</li> <li>The document is marked as \"processing\" in the local database</li> </ul>"},{"location":"processes/document-scanning/#6-job-polling-phase","title":"6. Job Polling Phase","text":"<ul> <li><code>JobPollingService</code> begins polling for job status</li> <li>When the job completes, <code>JobPollingService</code> retrieves and decrypts the results</li> <li>Processing results (extracted text, identified fields, etc.) are updated in the local database</li> <li>The document status is updated to \"processed\"</li> </ul>"},{"location":"processes/document-scanning/#7-ui-update-phase","title":"7. UI Update Phase","text":"<ul> <li>Database updates trigger Flow emissions with new values</li> <li><code>DocumentViewModel</code> receives updates and updates the UI state</li> <li><code>DocumentDetailScreen</code> automatically refreshes to display extracted text information</li> <li>User can view and interact with the processed document</li> </ul>"},{"location":"processes/document-scanning/#data-flow-and-state-management","title":"Data Flow and State Management","text":"<p>This process demonstrates the application's unidirectional data flow and reactive update mechanism:</p> <ol> <li>User Actions: User interactions trigger events in the UI layer</li> <li>ViewModel Processing: ViewModels process these events and update repositories</li> <li>Data Operations: Repositories perform data operations (local and remote)</li> <li>State Updates: Data changes update ViewModels' states</li> <li>UI Reactions: UI automatically reacts to state changes</li> </ol> <p>This pattern ensures consistency between the UI and the underlying data, making the application more predictable and easier to debug.</p>"},{"location":"processes/document-scanning/#error-handling","title":"Error Handling","text":"<p>The document scanning process includes robust error handling:</p> <ul> <li>Camera errors are handled with appropriate user feedback</li> <li>Image processing failures provide recovery options</li> <li>Network errors during backend processing are managed with retry mechanisms</li> <li>Job polling includes exponential backoff for failed attempts</li> <li>Database errors are handled with appropriate fallbacks</li> </ul> <p>These error handling mechanisms ensure that the document scanning process is resilient and provides a smooth user experience even when issues occur.</p>"},{"location":"processes/form-field-extraction/","title":"Form Field Extraction Process","text":"<p>Form field extraction is a key process in DocuSnap-Frontend that involves capturing form images, processing them, and extracting field information. This process is similar to document scanning but has specific differences in backend processing and data modeling.</p>"},{"location":"processes/form-field-extraction/#detailed-form-processing-flow","title":"Detailed Form Processing Flow","text":""},{"location":"processes/form-field-extraction/#1-form-capture-phase","title":"1. Form Capture Phase","text":"<ul> <li>User captures form images through the <code>CameraCaptureScreen</code></li> <li>Image data is passed to the <code>ImageProcessingScreen</code></li> <li>The camera interface provides guidance for optimal form capture</li> <li>Multiple images can be captured for multi-page forms</li> </ul>"},{"location":"processes/form-field-extraction/#2-image-processing-phase","title":"2. Image Processing Phase","text":"<ul> <li>Similar to document scanning, images undergo edge detection, perspective correction, and enhancement</li> <li>Processing is optimized specifically for form field recognition</li> <li>Enhanced images are passed to the <code>FormDetailScreen</code></li> </ul>"},{"location":"processes/form-field-extraction/#3-form-creation-phase","title":"3. Form Creation Phase","text":"<ul> <li><code>FormDetailScreen</code> calls <code>DocumentViewModel</code> (shared ViewModel) to create a form object</li> <li>User inputs form name, description, and tags</li> <li>ViewModel calls Repository to save the form</li> <li>Form metadata is associated with the processed images</li> </ul>"},{"location":"processes/form-field-extraction/#4-field-extraction-request-phase","title":"4. Field Extraction Request Phase","text":"<ul> <li>Repository calls <code>BackendApiService</code> to send the form to the backend for field extraction</li> <li>Backend returns a job ID, and a job record is created</li> <li><code>JobPollingService</code> begins polling for job status</li> <li>The form is marked as \"processing\" in the local database</li> </ul>"},{"location":"processes/form-field-extraction/#5-field-extraction-result-processing-phase","title":"5. Field Extraction Result Processing Phase","text":"<ul> <li>When the job completes, <code>JobPollingService</code> retrieves and decrypts the results</li> <li>Results include recognized form fields (names and values)</li> <li>Repository updates the form entity, adding the extracted fields</li> <li>The form status is updated to reflect the extraction completion</li> </ul>"},{"location":"processes/form-field-extraction/#6-field-editing-phase","title":"6. Field Editing Phase","text":"<ul> <li><code>FormDetailScreen</code> displays the extracted fields</li> <li>User can edit, confirm, or add fields</li> <li>Changes are saved to the database through the ViewModel</li> <li>Field validation rules can be applied during editing</li> </ul>"},{"location":"processes/form-field-extraction/#7-form-completion-phase","title":"7. Form Completion Phase","text":"<ul> <li>After editing, the form is marked as processed</li> <li>Form data can be exported or integrated with other systems</li> <li>Form usage statistics are updated</li> <li>Form is available for future reference and searching</li> </ul>"},{"location":"processes/form-field-extraction/#differences-from-document-scanning","title":"Differences from Document Scanning","text":"<p>While the form field extraction process shares similarities with document scanning, there are key differences:</p> <ol> <li>Field Recognition Focus:</li> <li>Forms focus on structured field extraction</li> <li>Documents focus on general text extraction</li> <li> <p>Form processing identifies field names and values as pairs</p> </li> <li> <p>User Interaction:</p> </li> <li>Form processing typically requires more user verification and editing</li> <li>Field values often need validation against specific rules</li> <li> <p>Form fields have relationships that need to be preserved</p> </li> <li> <p>Backend Processing:</p> </li> <li>Form processing uses specialized field extraction algorithms</li> <li>Form templates can be applied to improve recognition</li> <li> <p>Field extraction includes confidence scores for user verification</p> </li> <li> <p>Data Model:</p> </li> <li>Forms have a structured <code>formFields</code> collection</li> <li>Each field has a name, value, and extraction status</li> <li>Forms track field relationships and dependencies</li> </ol>"},{"location":"processes/form-field-extraction/#integration-with-other-systems","title":"Integration with Other Systems","text":"<p>The form field extraction process is designed to integrate with other systems:</p> <ol> <li>Data Export:</li> <li>Extracted form data can be exported in various formats (JSON, CSV, etc.)</li> <li> <p>Export includes both field data and form metadata</p> </li> <li> <p>Template Learning:</p> </li> <li>Frequently processed form types can be learned as templates</li> <li> <p>Templates improve future extraction accuracy for similar forms</p> </li> <li> <p>Workflow Integration:</p> </li> <li>Extracted form data can trigger workflows in other systems</li> <li>Integration APIs allow for seamless data transfer</li> </ol> <p>This form field extraction process demonstrates how DocuSnap-Frontend combines automated processing with user interaction to provide an efficient and accurate form data capture and management solution.</p>"},{"location":"processes/key-business-processes/","title":"Key Business Processes","text":"<p>In addition to document scanning and form field extraction, DocuSnap-Frontend includes several other key business processes. This page describes these important workflows in detail.</p>"},{"location":"processes/key-business-processes/#user-authentication-process","title":"User Authentication Process","text":"<p>DocuSnap-Frontend supports optional PIN code protection to ensure the security of sensitive documents:</p>"},{"location":"processes/key-business-processes/#pin-code-setup","title":"PIN Code Setup","text":"<ol> <li>User enables PIN code protection in the settings</li> <li>PIN code is hashed and stored in secure storage</li> <li>Biometric authentication can be enabled as an option</li> <li>Security settings are saved with user preferences</li> </ol>"},{"location":"processes/key-business-processes/#application-launch-authentication","title":"Application Launch Authentication","text":"<ol> <li>Application checks if PIN code protection is enabled at startup</li> <li>If enabled, navigation redirects to <code>PinVerificationScreen</code></li> <li>User enters PIN code or uses biometric authentication</li> <li>After successful verification, navigation proceeds to the main screen</li> <li>Failed attempts may implement increasing delays or lockouts</li> </ol>"},{"location":"processes/key-business-processes/#authentication-timeout","title":"Authentication Timeout","text":"<ol> <li>Application automatically locks after a certain period in the background</li> <li>Returning to the application requires re-verification</li> <li>Timeout duration can be configured in settings</li> <li>Critical operations may require re-authentication regardless of timeout</li> </ol>"},{"location":"processes/key-business-processes/#document-search-and-filtering-process","title":"Document Search and Filtering Process","text":"<p>The application provides powerful search and filtering capabilities:</p>"},{"location":"processes/key-business-processes/#search-initialization","title":"Search Initialization","text":"<ol> <li>User taps the search icon or navigates to the search screen</li> <li><code>SearchScreen</code> initializes, displaying recent searches and popular items</li> <li>Search interface provides filtering options and suggestions</li> <li>Recent searches are loaded from local storage</li> </ol>"},{"location":"processes/key-business-processes/#search-execution","title":"Search Execution","text":"<ol> <li>User enters search keywords</li> <li><code>SearchViewModel</code> calls Repository to execute the search</li> <li>Repository searches the local database for matches</li> <li>Search covers document names, descriptions, tags, and extracted text</li> <li>Results are ranked by relevance and recency</li> </ol>"},{"location":"processes/key-business-processes/#result-filtering","title":"Result Filtering","text":"<ol> <li>User can apply filters (such as date range, document type)</li> <li>Filtered results update in real-time</li> <li>Results are sorted by relevance or recent usage</li> <li>Filter combinations can be saved as presets</li> </ol>"},{"location":"processes/key-business-processes/#search-result-handling","title":"Search Result Handling","text":"<ol> <li>User taps a result item to navigate to the corresponding detail page</li> <li>Search history is updated</li> <li>Search statistics are collected to improve search algorithms</li> <li>Frequently searched terms may be suggested in future searches</li> </ol>"},{"location":"processes/key-business-processes/#form-editing-and-update-process","title":"Form Editing and Update Process","text":"<p>Form editing is an interactive process involving collaboration between the user and automated extraction results:</p>"},{"location":"processes/key-business-processes/#form-loading","title":"Form Loading","text":"<ol> <li>User selects a form from the form library</li> <li><code>FormDetailScreen</code> loads form data and extracted fields</li> <li>Form images and field list are displayed</li> <li>Field extraction confidence levels are indicated visually</li> </ol>"},{"location":"processes/key-business-processes/#field-editing","title":"Field Editing","text":"<ol> <li>User can edit field values, add new fields, or delete fields</li> <li>Editing is performed through the <code>ExtractedInfoItem</code> component</li> <li>Changes are saved to the in-memory form object in real-time</li> <li>Auto-save functionality may be enabled to prevent data loss</li> </ol>"},{"location":"processes/key-business-processes/#field-validation","title":"Field Validation","text":"<ol> <li>Some fields may have validation rules (such as date format, number range)</li> <li>Validation errors are displayed to the user with correction suggestions</li> <li>Form cannot be saved until validation passes</li> <li>Field types may have specific input methods (date picker, number input, etc.)</li> </ol>"},{"location":"processes/key-business-processes/#form-update","title":"Form Update","text":"<ol> <li>User saves the form after completing edits</li> <li>ViewModel calls Repository to update the database</li> <li>Updated form can be exported or shared</li> <li>Form usage statistics are updated</li> </ol>"},{"location":"processes/key-business-processes/#document-export-and-sharing-process","title":"Document Export and Sharing Process","text":"<p>DocuSnap-Frontend provides secure methods for exporting and sharing documents:</p>"},{"location":"processes/key-business-processes/#export-preparation","title":"Export Preparation","text":"<ol> <li>User selects export option from document or form detail screen</li> <li>Export format options are presented (PDF, JSON, CSV, etc.)</li> <li>User selects desired format and export options</li> <li>Export preview may be shown for confirmation</li> </ol>"},{"location":"processes/key-business-processes/#export-execution","title":"Export Execution","text":"<ol> <li>Document or form data is formatted according to selected export format</li> <li>For secure formats, encryption options may be presented</li> <li>Export process executes, generating the output file</li> <li>Progress is displayed for large documents or forms</li> </ol>"},{"location":"processes/key-business-processes/#sharing","title":"Sharing","text":"<ol> <li>After export, sharing options are presented</li> <li>Standard Android sharing dialog allows sending to other apps</li> <li>Direct sharing to common destinations may be featured</li> <li>Sharing history may be tracked for frequently used destinations</li> </ol>"},{"location":"processes/key-business-processes/#export-security","title":"Export Security","text":"<ol> <li>Exported documents can be password-protected</li> <li>Sensitive data can be redacted before export</li> <li>Watermarks or metadata can be added for tracking</li> <li>Export logs maintain records of what was shared and when</li> </ol>"},{"location":"processes/key-business-processes/#data-synchronization-process","title":"Data Synchronization Process","text":"<p>For users with multiple devices or cloud backup needs, DocuSnap-Frontend implements data synchronization:</p>"},{"location":"processes/key-business-processes/#sync-configuration","title":"Sync Configuration","text":"<ol> <li>User enables synchronization in settings</li> <li>Authentication with sync service is performed</li> <li>Sync preferences (what to sync, frequency, etc.) are configured</li> <li>Initial sync status is displayed</li> </ol>"},{"location":"processes/key-business-processes/#automatic-synchronization","title":"Automatic Synchronization","text":"<ol> <li>Changes to documents or forms trigger sync events</li> <li>Sync service queues changes for upload</li> <li>Background sync occurs based on configured conditions (Wi-Fi only, charging, etc.)</li> <li>Conflict resolution policies are applied for simultaneous edits</li> </ol>"},{"location":"processes/key-business-processes/#manual-synchronization","title":"Manual Synchronization","text":"<ol> <li>User can trigger manual sync from settings</li> <li>Sync progress is displayed with detailed status</li> <li>Errors are reported with retry options</li> <li>Sync history shows recent successful and failed syncs</li> </ol>"},{"location":"processes/key-business-processes/#offline-operation","title":"Offline Operation","text":"<ol> <li>All core functions work offline</li> <li>Changes are queued for sync when connectivity returns</li> <li>Sync status indicators show pending changes</li> <li>Critical operations may warn if they haven't been synced</li> </ol> <p>These key business processes demonstrate how DocuSnap-Frontend handles complex user interactions and data management requirements, providing a comprehensive document and form management solution.</p>"},{"location":"quality/code-structure/","title":"Code Structure Analysis","text":"<p>DocuSnap-Frontend follows modern Android development best practices in its code organization and structure, demonstrating good design principles and maintainability.</p>"},{"location":"quality/code-structure/#package-organization","title":"Package Organization","text":"<p>The application's package structure is clearly divided by functionality and layers:</p> <pre><code>cn.edu.sjtu.deepsleep.docusnap/\n\u251c\u2500\u2500 data/\n\u2502   \u251c\u2500\u2500 local/          # Local data storage (Room database)\n\u2502   \u251c\u2500\u2500 model/          # Data model definitions\n\u2502   \u251c\u2500\u2500 remote/         # Remote API services\n\u2502   \u2514\u2500\u2500 repository/     # Repository layer\n\u251c\u2500\u2500 navigation/         # Navigation control\n\u251c\u2500\u2500 service/            # Service layer\n\u251c\u2500\u2500 ui/\n\u2502   \u251c\u2500\u2500 components/     # UI components\n\u2502   \u251c\u2500\u2500 screens/        # Screen interfaces\n\u2502   \u2514\u2500\u2500 theme/          # Theme styles\n\u251c\u2500\u2500 util/               # Utility classes\n\u251c\u2500\u2500 viewmodels/         # ViewModel layer\n\u251c\u2500\u2500 AppModule.kt        # Dependency injection\n\u2514\u2500\u2500 MainActivity.kt     # Main activity\n</code></pre> <p>This package organization has several advantages: - Grouped by functionality and layer, making it easy to locate and understand - Follows the principle of separation of concerns, reducing coupling - Supports modular development and testing - Makes it easier for new developers to understand the project structure</p>"},{"location":"quality/code-structure/#naming-conventions","title":"Naming Conventions","text":"<p>The application follows standard Kotlin naming conventions: - Class names use PascalCase (e.g., <code>DocumentViewModel</code>) - Functions and variables use camelCase (e.g., <code>loadDocuments</code>) - Constants use UPPER_SNAKE_CASE (e.g., <code>MAX_RETRY_COUNT</code>) - Package names use lowercase (e.g., <code>cn.edu.sjtu.deepsleep.docusnap</code>)</p> <p>Names also follow semantic principles, clearly expressing intent: - Action functions start with verbs (e.g., <code>loadDocuments</code>, <code>saveDocument</code>) - Boolean properties use is/has/should prefixes (e.g., <code>isLoading</code>, <code>hasChanges</code>) - Collections use plural forms (e.g., <code>documents</code>, <code>extractedInfo</code>)</p>"},{"location":"quality/code-structure/#code-reuse","title":"Code Reuse","text":"<p>The application achieves good code reuse through several mechanisms:</p>"},{"location":"quality/code-structure/#1-abstract-base-classes","title":"1. Abstract Base Classes","text":"<ul> <li>Shared functionality is provided through base classes</li> <li>Specific functionality is implemented through inheritance and overriding</li> <li>Common behaviors are defined once and reused across multiple components</li> </ul>"},{"location":"quality/code-structure/#2-extension-functions","title":"2. Extension Functions","text":"<ul> <li>Kotlin extension functions are used to enhance existing classes</li> <li>This approach avoids creating numerous utility classes</li> <li>Extensions provide clear, concise ways to add functionality</li> </ul> <p>Example: <pre><code>// Extension function for bitmap processing\nfun Bitmap.applyGrayscale(): Bitmap {\n    val result = Bitmap.createBitmap(width, height, config)\n    val canvas = Canvas(result)\n    val paint = Paint()\n    val colorMatrix = ColorMatrix()\n    colorMatrix.setSaturation(0f)\n    paint.colorFilter = ColorMatrixColorFilter(colorMatrix)\n    canvas.drawBitmap(this, 0f, 0f, paint)\n    return result\n}\n</code></pre></p>"},{"location":"quality/code-structure/#3-higher-order-functions","title":"3. Higher-Order Functions","text":"<ul> <li>Higher-order functions abstract common behaviors</li> <li>This reduces code duplication</li> <li>Enhances flexibility through strategy pattern implementation</li> </ul> <p>Example: <pre><code>// Higher-order function for applying filters\nprivate fun applyFilter(filterName: String, filter: suspend (Bitmap) -&gt; Bitmap) {\n    viewModelScope.launch {\n        val bitmap = _uiState.value.editingBitmap ?: return@launch\n        _uiState.update { it.copy(isLoading = true) }\n\n        try {\n            val filteredBitmap = filter(bitmap)\n            _uiState.update { it.copy(\n                editingBitmap = filteredBitmap,\n                appliedFilter = filterName,\n                isLoading = false\n            )}\n        } catch (e: Exception) {\n            _uiState.update { it.copy(isLoading = false) }\n            // Error handling\n        }\n    }\n}\n</code></pre></p>"},{"location":"quality/code-structure/#4-shared-components","title":"4. Shared Components","text":"<ul> <li>UI components are designed to be reusable</li> <li>Business logic is encapsulated in shared services</li> <li>Common utilities are centralized and accessible throughout the application</li> </ul>"},{"location":"quality/code-structure/#asynchronous-programming","title":"Asynchronous Programming","text":"<p>The application employs modern asynchronous programming practices:</p>"},{"location":"quality/code-structure/#1-coroutines-and-flow","title":"1. Coroutines and Flow","text":"<ul> <li>Kotlin coroutines handle asynchronous operations</li> <li>Flow implements reactive data streams</li> <li>Appropriate coroutine scope and lifecycle management</li> </ul> <p>Example: <pre><code>fun loadDocuments() {\n    viewModelScope.launch {\n        _isLoading.value = true\n        try {\n            val docs = repository.getAllDocuments()\n            _documents.value = docs\n        } catch (e: Exception) {\n            // Error handling\n        } finally {\n            _isLoading.value = false\n        }\n    }\n}\n</code></pre></p>"},{"location":"quality/code-structure/#2-structured-concurrency","title":"2. Structured Concurrency","text":"<ul> <li><code>viewModelScope</code> automatically manages coroutines</li> <li><code>SupervisorJob</code> handles error propagation</li> <li>Appropriate cancellation of unnecessary coroutines</li> </ul>"},{"location":"quality/code-structure/#3-asynchronous-boundaries","title":"3. Asynchronous Boundaries","text":"<ul> <li>Asynchronous operations are handled in Repository and ViewModel layers</li> <li>UI layer stays synchronized through state collection</li> <li>Long-running operations are moved off the UI thread</li> </ul>"},{"location":"quality/code-structure/#file-organization","title":"File Organization","text":"<p>The application's file organization follows logical patterns:</p> <ol> <li>Related functionality is grouped in the same package</li> <li>File size is kept manageable, with large classes split into smaller, focused ones</li> <li>Interface and implementation separation is used where appropriate</li> <li>Resource files are organized by type and purpose</li> <li>Configuration files are kept at appropriate levels of the project structure</li> </ol> <p>This structured approach to code organization contributes to the overall maintainability and readability of the DocuSnap-Frontend codebase.</p>"},{"location":"quality/design-patterns/","title":"Design Patterns Implementation","text":"<p>DocuSnap-Frontend implements several design patterns to improve code quality, maintainability, and extensibility. This page analyzes how these patterns are applied throughout the application.</p>"},{"location":"quality/design-patterns/#mvvm-pattern-implementation","title":"MVVM Pattern Implementation","text":"<p>The application fully adopts the MVVM (Model-View-ViewModel) architecture pattern, implementing these core concepts:</p>"},{"location":"quality/design-patterns/#1-data-binding","title":"1. Data Binding","text":"<ul> <li>Implemented through StateFlow and collectAsState</li> <li>UI automatically responds to data changes</li> <li>Example:</li> </ul> <pre><code>// In ViewModel\nprivate val _documents = MutableStateFlow&lt;List&lt;Document&gt;&gt;(emptyList())\nval documents: StateFlow&lt;List&lt;Document&gt;&gt; = _documents.asStateFlow()\n\n// In UI\nval documents by viewModel.documents.collectAsState()\n</code></pre>"},{"location":"quality/design-patterns/#2-state-management","title":"2. State Management","text":"<ul> <li>ViewModels encapsulate and manage UI state</li> <li>Immutable state objects improve predictability</li> <li>Example:</li> </ul> <pre><code>data class ImageProcessingUiState(\n    val isLoading: Boolean = false,\n    val originalImageUris: List&lt;String&gt; = emptyList(),\n    val currentImageIndex: Int = 0,\n    val editingBitmap: Bitmap? = null,\n    // Other state properties\n)\n</code></pre>"},{"location":"quality/design-patterns/#3-command-pattern","title":"3. Command Pattern","text":"<ul> <li>User actions are executed through ViewModel methods</li> <li>Operation results are reflected in UI through state updates</li> <li>Example:</li> </ul> <pre><code>// Command execution in ViewModel\nfun deleteDocument(id: String) {\n    viewModelScope.launch {\n        repository.deleteDocument(id)\n        loadDocuments() // Refresh list\n    }\n}\n</code></pre>"},{"location":"quality/design-patterns/#mvvm-implementation-quality-assessment","title":"MVVM Implementation Quality Assessment","text":"<ul> <li>Strengths: Clear separation of concerns, good state management</li> <li>Areas for Improvement: Some ViewModels could be further divided to reduce complexity</li> </ul>"},{"location":"quality/design-patterns/#repository-pattern-application","title":"Repository Pattern Application","text":"<p>The Repository pattern is well-implemented in the application:</p>"},{"location":"quality/design-patterns/#1-data-abstraction","title":"1. Data Abstraction","text":"<ul> <li>Repositories abstract data source details</li> <li>Provide unified data access interfaces</li> <li>Example:</li> </ul> <pre><code>class DocumentRepository(private val deviceDBService: DeviceDBService) {\n    suspend fun getAllDocuments(): List&lt;Document&gt; {\n        return deviceDBService.getDocumentGallery().mapNotNull { json -&gt;\n            // Mapping logic\n        }\n    }\n}\n</code></pre>"},{"location":"quality/design-patterns/#2-data-transformation","title":"2. Data Transformation","text":"<ul> <li>Converts between entities and models</li> <li>Handles data format and structure changes</li> <li>Example:</li> </ul> <pre><code>suspend fun getDocument(id: String): Document? {\n    val json = deviceDBService.getDocument(id) ?: return null\n    return try {\n        Document(\n            id = json.getString(\"id\"),\n            name = json.getString(\"name\"),\n            // Other property mapping\n        )\n    } catch (e: Exception) {\n        null\n    }\n}\n</code></pre>"},{"location":"quality/design-patterns/#3-caching-strategy","title":"3. Caching Strategy","text":"<ul> <li>Implements local caching to improve performance</li> <li>Handles online/offline states</li> <li>Example:</li> </ul> <pre><code>suspend fun getDocumentWithCache(id: String): Document? {\n    // Check cache first\n    cachedDocuments[id]?.let { return it }\n\n    // If not in cache, load from database\n    val document = getDocument(id)\n\n    // Update cache\n    document?.let { cachedDocuments[id] = it }\n\n    return document\n}\n</code></pre>"},{"location":"quality/design-patterns/#repository-pattern-quality-assessment","title":"Repository Pattern Quality Assessment","text":"<ul> <li>Strengths: Good data source abstraction, clear responsibility division</li> <li>Areas for Improvement: Could enhance caching strategy, optimize data synchronization mechanisms</li> </ul>"},{"location":"quality/design-patterns/#observer-pattern-flow","title":"Observer Pattern (Flow)","text":"<p>The application uses Kotlin Flow to implement the Observer pattern:</p>"},{"location":"quality/design-patterns/#1-data-streams","title":"1. Data Streams","text":"<ul> <li>StateFlow manages UI state</li> <li>Flow retrieves data from database</li> <li>Example:</li> </ul> <pre><code>@Query(\"SELECT * FROM documents ORDER BY last_used DESC\")\nfun getAllDocuments(): Flow&lt;List&lt;DocumentEntity&gt;&gt;\n</code></pre>"},{"location":"quality/design-patterns/#2-automatic-updates","title":"2. Automatic Updates","text":"<ul> <li>UI automatically updates through collectAsState</li> <li>Data changes propagate to all observers</li> <li>Example:</li> </ul> <pre><code>@Composable\nfun DocumentScreen(viewModel: DocumentViewModel) {\n    val documents by viewModel.documents.collectAsState()\n\n    LazyColumn {\n        items(documents) { document -&gt;\n            DocumentItem(document)\n        }\n    }\n}\n</code></pre>"},{"location":"quality/design-patterns/#3-operator-chains","title":"3. Operator Chains","text":"<ul> <li>Flow operators process data transformations</li> <li>Implement complex data processing workflows</li> <li>Example:</li> </ul> <pre><code>repository.searchDocuments(query)\n    .map { documents -&gt; documents.sortedByDescending { it.lastUsed } }\n    .filter { documents -&gt; documents.isNotEmpty() }\n    .catch { emit(emptyList()) }\n    .collect { documents -&gt;\n        _searchResults.value = documents\n    }\n</code></pre>"},{"location":"quality/design-patterns/#flow-implementation-quality-assessment","title":"Flow Implementation Quality Assessment","text":"<ul> <li>Strengths: Concise reactive programming model, reduced boilerplate code</li> <li>Areas for Improvement: Could better handle backpressure and error propagation</li> </ul>"},{"location":"quality/design-patterns/#factory-pattern-and-strategy-pattern","title":"Factory Pattern and Strategy Pattern","text":"<p>The application implements several other design patterns:</p>"},{"location":"quality/design-patterns/#1-factory-pattern","title":"1. Factory Pattern","text":"<ul> <li>ViewModelFactory creates ViewModel instances</li> <li>Supports dependency injection and testing</li> <li>Example:</li> </ul> <pre><code>class DocumentViewModelFactory(\n    private val repository: DocumentRepository\n) : ViewModelProvider.Factory {\n    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {\n        if (modelClass.isAssignableFrom(DocumentViewModel::class.java)) {\n            @Suppress(\"UNCHECKED_CAST\")\n            return DocumentViewModel(repository) as T\n        }\n        throw IllegalArgumentException(\"Unknown ViewModel class\")\n    }\n}\n</code></pre>"},{"location":"quality/design-patterns/#2-strategy-pattern","title":"2. Strategy Pattern","text":"<ul> <li>Encapsulates different algorithms in image processing</li> <li>Supports dynamic algorithm switching and configuration</li> <li>Example:</li> </ul> <pre><code>// Strategy selection through higher-order functions\nfun applyFilter(filterName: String, filter: suspend (Bitmap) -&gt; Bitmap) {\n    // Implementation\n}\n\n// Strategy usage\napplyBinarizationFilter() {\n    applyFilter(\"Black &amp; White\") { bitmap -&gt;\n        imageProcService.applyThresholdFilter(bitmap, 4)\n    }\n}\n</code></pre>"},{"location":"quality/design-patterns/#3-command-pattern_1","title":"3. Command Pattern","text":"<ul> <li>Operations are encapsulated as independent commands</li> <li>Supports operation history and undo functionality</li> <li>Example:</li> </ul> <pre><code>sealed class ImageProcessingCommand {\n    data class ApplyFilter(val filterType: String, val parameters: Map&lt;String, Any&gt;) : ImageProcessingCommand()\n    data class Crop(val rect: Rect) : ImageProcessingCommand()\n    data class Rotate(val degrees: Float) : ImageProcessingCommand()\n    object Reset : ImageProcessingCommand()\n}\n</code></pre>"},{"location":"quality/design-patterns/#4-adapter-pattern","title":"4. Adapter Pattern","text":"<ul> <li>Adapts REST API through Retrofit interface</li> <li>Converts HTTP requests to local method calls</li> <li>Example:</li> </ul> <pre><code>interface BackendApiInterface {\n    @POST(\"process\")\n    suspend fun process(@Body requestBody: String): JSONObject\n\n    @POST(\"status\")\n    suspend fun checkStatus(@Body requestBody: String): JSONObject\n}\n</code></pre>"},{"location":"quality/design-patterns/#5-decorator-pattern","title":"5. Decorator Pattern","text":"<ul> <li>Enhances objects with additional functionality</li> <li>Used in security and logging aspects</li> <li>Example:</li> </ul> <pre><code>// Encryption decorator for API communication\nprivate suspend fun process(\n    type: String,\n    payload: Any\n): ProcessingResult {\n    // Original data preparation\n    val innerJson = JSONObject().apply {\n        // Setup payload\n    }\n\n    // Decoration with encryption\n    val aesKey = cryptoUtil.generateAesKey()\n    val encryptedContent = cryptoUtil.aesEncrypt(innerJson.toString().toByteArray(), aesKey)\n    val sha256 = cryptoUtil.computeSHA256(encryptedContent)\n    val encryptedAesKey = cryptoUtil.rsaEncrypt(aesKey, cryptoUtil.getPublicKey(settingsManager.getPublicKeyPem()))\n\n    // Continue with decorated data\n}\n</code></pre>"},{"location":"quality/design-patterns/#design-pattern-quality-assessment","title":"Design Pattern Quality Assessment","text":"<p>The application's use of design patterns demonstrates a good understanding of software design principles:</p> <ul> <li>Strengths: Enhances code flexibility and extensibility, follows established patterns</li> <li>Areas for Improvement: Could apply patterns more consistently across the codebase</li> </ul> <p>Overall, DocuSnap-Frontend effectively leverages design patterns to create a maintainable, flexible, and robust application architecture.</p>"},{"location":"quality/strengths-improvements/","title":"Code Quality Strengths and Improvements","text":"<p>This section analyzes the code quality strengths and areas for improvement in the DocuSnap-Frontend application.</p>"},{"location":"quality/strengths-improvements/#code-quality-strengths","title":"Code Quality Strengths","text":""},{"location":"quality/strengths-improvements/#1-clear-architecture-layering","title":"1. Clear Architecture Layering","text":"<ul> <li>Well-defined layer structure and responsibility division</li> <li>Good separation of concerns</li> <li>Modular design facilitates maintenance and extension</li> <li>Example:</li> <li>UI layer handles only presentation and user interaction</li> <li>ViewModel layer manages state and business logic</li> <li>Repository layer abstracts data access</li> <li>Each layer has clear boundaries and interfaces</li> </ul>"},{"location":"quality/strengths-improvements/#2-reactive-programming","title":"2. Reactive Programming","text":"<ul> <li>Effective use of Flow and StateFlow for reactive UI</li> <li>Reduces state management complexity</li> <li>Improves code readability and maintainability</li> <li>Example:   <pre><code>// Reactive state management\nprivate val _documents = MutableStateFlow&lt;List&lt;Document&gt;&gt;(emptyList())\nval documents: StateFlow&lt;List&lt;Document&gt;&gt; = _documents.asStateFlow()\n\n// UI automatically updates when state changes\nval documents by viewModel.documents.collectAsState()\n</code></pre></li> </ul>"},{"location":"quality/strengths-improvements/#3-secure-communication","title":"3. Secure Communication","text":"<ul> <li>Implementation of end-to-end encryption</li> <li>Multiple security layers protect data</li> <li>Good key management and secure storage</li> <li>Example:   <pre><code>// Hybrid encryption implementation\nval aesKey = cryptoUtil.generateAesKey()\nval encryptedContent = cryptoUtil.aesEncrypt(data, aesKey)\nval encryptedAesKey = cryptoUtil.rsaEncrypt(aesKey, publicKey)\n</code></pre></li> </ul>"},{"location":"quality/strengths-improvements/#4-exception-handling","title":"4. Exception Handling","text":"<ul> <li>Multi-layer exception handling strategy</li> <li>Appropriate error propagation and recovery mechanisms</li> <li>User-friendly error messages</li> <li>Example:   <pre><code>try {\n    val docs = repository.getAllDocuments()\n    _documents.value = docs\n} catch (e: NetworkException) {\n    _error.value = \"Network error: ${e.message}\"\n} catch (e: DatabaseException) {\n    _error.value = \"Database error: ${e.message}\"\n} catch (e: Exception) {\n    _error.value = \"Unknown error occurred\"\n    Log.e(TAG, \"Error loading documents\", e)\n} finally {\n    _isLoading.value = false\n}\n</code></pre></li> </ul>"},{"location":"quality/strengths-improvements/#5-code-consistency","title":"5. Code Consistency","text":"<ul> <li>Consistent naming conventions and code style</li> <li>Unified architecture pattern application</li> <li>Good documentation and comments</li> <li>Example:</li> <li>All ViewModels follow the same pattern for state management</li> <li>Repository implementations have consistent interfaces</li> <li>Error handling follows established patterns throughout the codebase</li> </ul>"},{"location":"quality/strengths-improvements/#areas-for-improvement","title":"Areas for Improvement","text":""},{"location":"quality/strengths-improvements/#1-class-size-control","title":"1. Class Size Control","text":"<ul> <li>Some classes (like <code>ImageProcService</code>) are too large</li> <li>Recommendation: Split into multiple focused classes</li> <li>Example:</li> <li>Current: One large <code>ImageProcService</code> handling all image processing</li> <li>Improved: Separate into <code>EdgeDetectionService</code>, <code>PerspectiveCorrectionService</code>, <code>ImageFilterService</code>, etc.</li> <li>This would improve maintainability and testability</li> </ul>"},{"location":"quality/strengths-improvements/#2-error-handling-consistency","title":"2. Error Handling Consistency","text":"<ul> <li>Error handling strategies vary between modules</li> <li>Recommendation: Define a unified error handling framework</li> <li>Example:</li> <li>Create a common <code>Result&lt;T&gt;</code> wrapper for all operations</li> <li>Implement consistent error types and recovery strategies</li> <li>Add more granular error reporting   <pre><code>sealed class AppError {\n    data class NetworkError(val code: Int, val message: String) : AppError()\n    data class DatabaseError(val operation: String, val message: String) : AppError()\n    data class ProcessingError(val stage: String, val message: String) : AppError()\n    data class ValidationError(val field: String, val message: String) : AppError()\n}\n\ntypealias Result&lt;T&gt; = Either&lt;AppError, T&gt;\n</code></pre></li> </ul>"},{"location":"quality/strengths-improvements/#3-test-coverage","title":"3. Test Coverage","text":"<ul> <li>Unit test coverage could be improved</li> <li>Recommendation: Increase test coverage, especially for ViewModels and Repositories</li> <li>Example:</li> <li>Add comprehensive ViewModel tests:   <pre><code>@Test\nfun `loadDocuments should update state with documents from repository`() = runTest {\n    // Arrange\n    val documents = listOf(createTestDocument(), createTestDocument())\n    coEvery { repository.getAllDocuments() } returns documents\n\n    // Act\n    viewModel.loadDocuments()\n\n    // Assert\n    assertEquals(documents, viewModel.documents.value)\n    assertEquals(false, viewModel.isLoading.value)\n}\n</code></pre></li> </ul>"},{"location":"quality/strengths-improvements/#4-dependency-injection-framework","title":"4. Dependency Injection Framework","text":"<ul> <li>Currently using simple manual dependency injection</li> <li>Recommendation: Consider using Dagger Hilt or another DI framework</li> <li>Example:</li> <li>Current approach:   <pre><code>// In MainActivity\nval documentRepository = remember { AppModule.provideDocumentRepository(context) }\nval documentViewModel = remember { DocumentViewModel(documentRepository) }\n</code></pre></li> <li>With Hilt:   <pre><code>@HiltViewModel\nclass DocumentViewModel @Inject constructor(\n    private val repository: DocumentRepository\n) : ViewModel() { /* ... */ }\n\n@AndroidEntryPoint\nclass MainActivity : ComponentActivity() { /* ... */ }\n</code></pre></li> </ul>"},{"location":"quality/strengths-improvements/#5-concurrency-control","title":"5. Concurrency Control","text":"<ul> <li>Some concurrent scenarios could be better handled</li> <li>Recommendation: Improve synchronization mechanisms</li> <li>Example:</li> <li>Use mutex for critical sections:   <pre><code>private val mutex = Mutex()\n\nsuspend fun updateDocument(document: Document) {\n    mutex.withLock {\n        // Critical section - safe from concurrent modification\n        localCache[document.id] = document\n        deviceDBService.saveDocument(document.toJson())\n    }\n}\n</code></pre></li> </ul>"},{"location":"quality/strengths-improvements/#6-logging-strategy","title":"6. Logging Strategy","text":"<ul> <li>Logging could be more comprehensive and structured</li> <li>Recommendation: Implement a consistent logging strategy</li> <li>Example:</li> <li>Create a centralized logging service:   <pre><code>object AppLogger {\n    fun d(tag: String, message: String, vararg args: Any) {\n        if (BuildConfig.DEBUG) {\n            Log.d(tag, message.format(*args))\n        }\n    }\n\n    fun e(tag: String, message: String, throwable: Throwable? = null) {\n        Log.e(tag, message, throwable)\n        // Could also send to crash reporting service\n    }\n\n    // Other log levels...\n}\n</code></pre></li> </ul>"},{"location":"quality/strengths-improvements/#recommendations-for-improvement","title":"Recommendations for Improvement","text":"<ol> <li> <p>Refactor Large Classes: Break down large classes into smaller, focused components with single responsibilities.</p> </li> <li> <p>Standardize Error Handling: Create a unified error handling framework used consistently across the application.</p> </li> <li> <p>Increase Test Coverage: Add unit tests for all ViewModels and Repositories, and integration tests for key workflows.</p> </li> <li> <p>Adopt Dependency Injection Framework: Implement Dagger Hilt for more robust dependency management.</p> </li> <li> <p>Improve Documentation: Add more comprehensive documentation, especially for complex algorithms and business logic.</p> </li> <li> <p>Enhance Monitoring: Implement better logging, analytics, and performance monitoring.</p> </li> <li> <p>Code Review Process: Establish stricter code review guidelines focusing on maintainability and testability.</p> </li> </ol> <p>These improvements would further enhance the already well-structured codebase, making it more maintainable, testable, and robust.</p>"},{"location":"summary/architecture-advantages/","title":"Architecture Advantages Summary","text":"<p>DocuSnap-Frontend employs a modern Android development architecture that offers numerous advantages. This page summarizes the key architectural strengths of the application.</p>"},{"location":"summary/architecture-advantages/#clear-architecture-layering","title":"Clear Architecture Layering","text":"<p>DocuSnap-Frontend implements a well-structured layered architecture with clear separation of concerns:</p> <ol> <li>MVVM Architecture Pattern</li> <li>Clear separation between UI, business logic, and data access</li> <li>Each layer has well-defined responsibilities</li> <li> <p>Improves code maintainability and testability</p> </li> <li> <p>Repository Pattern</p> </li> <li>Abstracts data source details</li> <li>Provides a unified data interface</li> <li> <p>Simplifies data access and caching strategies</p> </li> <li> <p>Service Layer</p> </li> <li>Encapsulates complex business logic</li> <li>Provides reusable services across the application</li> <li> <p>Handles background processing and external integrations</p> </li> <li> <p>Clear Module Boundaries</p> </li> <li>Core modules have well-defined interfaces</li> <li>Reduces coupling between components</li> <li>Facilitates parallel development and testing</li> </ol>"},{"location":"summary/architecture-advantages/#reactive-programming-model","title":"Reactive Programming Model","text":"<p>The application leverages reactive programming principles for efficient state management:</p> <ol> <li>Kotlin Flow and StateFlow</li> <li>Implements reactive data streams</li> <li>Simplifies asynchronous operations</li> <li> <p>Provides automatic UI updates based on data changes</p> </li> <li> <p>Unidirectional Data Flow</p> </li> <li>Predictable state management</li> <li>Easier debugging and testing</li> <li> <p>Reduces state-related bugs</p> </li> <li> <p>Declarative UI with Jetpack Compose</p> </li> <li>UI automatically reflects state changes</li> <li>Reduces boilerplate code</li> <li> <p>Improves UI consistency</p> </li> <li> <p>Lifecycle-aware Components</p> </li> <li>Components respect Android lifecycle</li> <li>Prevents memory leaks</li> <li>Handles configuration changes gracefully</li> </ol>"},{"location":"summary/architecture-advantages/#modular-design","title":"Modular Design","text":"<p>The application's modular design offers significant advantages:</p> <ol> <li>Core Functional Modules</li> <li>Document processing, form processing, image processing, and backend communication modules</li> <li>Each module focuses on specific functionality</li> <li> <p>Modules can be developed and tested independently</p> </li> <li> <p>Clear Interfaces</p> </li> <li>Modules communicate through well-defined interfaces</li> <li>Reduces coupling between modules</li> <li> <p>Facilitates module replacement or enhancement</p> </li> <li> <p>Team Collaboration Support</p> </li> <li>Different team members can work on different modules</li> <li>Reduced merge conflicts</li> <li> <p>Parallel development workflows</p> </li> <li> <p>Feature Encapsulation</p> </li> <li>Features are encapsulated within modules</li> <li>Feature toggles can be implemented at module level</li> <li>Supports incremental feature delivery</li> </ol>"},{"location":"summary/architecture-advantages/#secure-communication","title":"Secure Communication","text":"<p>The application implements robust security measures:</p> <ol> <li>End-to-End Encryption</li> <li>Hybrid encryption system (RSA + AES)</li> <li>Protects sensitive data during transmission</li> <li> <p>Unique encryption keys for each session</p> </li> <li> <p>Data Integrity Verification</p> </li> <li>SHA-256 hash verification</li> <li>Prevents data tampering</li> <li> <p>Ensures data authenticity</p> </li> <li> <p>Local Security</p> </li> <li>PIN code and biometric protection</li> <li>Secure local storage</li> <li> <p>Session management and timeout</p> </li> <li> <p>Defense in Depth</p> </li> <li>Multiple security layers</li> <li>No single point of security failure</li> <li>Comprehensive protection strategy</li> </ol>"},{"location":"summary/architecture-advantages/#modern-ui","title":"Modern UI","text":"<p>The application provides a modern, user-friendly interface:</p> <ol> <li>Jetpack Compose</li> <li>Modern declarative UI framework</li> <li>Simplified UI development</li> <li> <p>Improved UI consistency</p> </li> <li> <p>Material Design 3</p> </li> <li>Latest Material design guidelines</li> <li>Modern visual experience</li> <li> <p>Consistent design language</p> </li> <li> <p>Responsive Design</p> </li> <li>Adapts to different screen sizes</li> <li>Supports different orientations</li> <li> <p>Accessible UI elements</p> </li> <li> <p>Smooth Animations and Transitions</p> </li> <li>Enhances user experience</li> <li>Provides visual feedback</li> <li>Guides user attention</li> </ol>"},{"location":"summary/architecture-advantages/#offline-functionality","title":"Offline Functionality","text":"<p>The application supports robust offline operations:</p> <ol> <li>Local Database</li> <li>Room database for local storage</li> <li>Offline data access and manipulation</li> <li> <p>Persistent data across app restarts</p> </li> <li> <p>Data Synchronization</p> </li> <li>Background synchronization when online</li> <li>Conflict resolution strategies</li> <li> <p>Seamless online/offline transition</p> </li> <li> <p>Queued Operations</p> </li> <li>Operations are queued when offline</li> <li>Executed when connectivity returns</li> <li> <p>Preserves user intent</p> </li> <li> <p>Offline-First Design</p> </li> <li>Core functionality works without network</li> <li>Graceful degradation of features</li> <li>Prioritizes user experience</li> </ol>"},{"location":"summary/architecture-advantages/#scalability-and-extensibility","title":"Scalability and Extensibility","text":"<p>The architecture is designed for growth and adaptation:</p> <ol> <li>Extensible Design Patterns</li> <li>Strategy pattern for algorithm variations</li> <li>Factory pattern for object creation</li> <li> <p>Observer pattern for event handling</p> </li> <li> <p>Plugin Architecture</p> </li> <li>New processing algorithms can be added</li> <li>Backend services can be extended</li> <li> <p>UI components are reusable and composable</p> </li> <li> <p>Configuration-Driven Behavior</p> </li> <li>Features can be enabled/disabled via configuration</li> <li>Parameters can be adjusted without code changes</li> <li> <p>Supports A/B testing and feature flags</p> </li> <li> <p>Future-Ready Architecture</p> </li> <li>Prepared for new Android features</li> <li>Compatible with modern development practices</li> <li>Supports long-term evolution</li> </ol> <p>These architectural advantages make DocuSnap-Frontend a robust, maintainable, and user-friendly application that can evolve to meet changing requirements while maintaining high quality and security standards.</p>"},{"location":"summary/future-optimizations/","title":"Future Optimization Recommendations","text":"<p>Based on the analysis of DocuSnap-Frontend's architecture and code quality, this page provides recommendations for future optimizations and improvements.</p>"},{"location":"summary/future-optimizations/#modular-refactoring","title":"Modular Refactoring","text":""},{"location":"summary/future-optimizations/#1-split-large-classes","title":"1. Split Large Classes","text":"<p>Current Issue: Some classes (like <code>ImageProcService</code>) are too large and have multiple responsibilities.</p> <p>Recommendation: Refactor large classes into smaller, focused components:</p> <ul> <li> <p>Split <code>ImageProcService</code> into specialized services:   <pre><code>class EdgeDetectionService { /* Edge detection algorithms */ }\nclass PerspectiveCorrectionService { /* Perspective correction */ }\nclass ImageFilterService { /* Image filters */ }\n</code></pre></p> </li> <li> <p>Benefits:</p> </li> <li>Improved maintainability</li> <li>Better testability</li> <li>Clearer responsibilities</li> <li>Easier to extend with new features</li> </ul>"},{"location":"summary/future-optimizations/#2-implement-dependency-injection-framework","title":"2. Implement Dependency Injection Framework","text":"<p>Current Issue: Currently using simple manual dependency injection.</p> <p>Recommendation: Adopt Dagger Hilt for dependency injection:</p> <ul> <li> <p>Configure Hilt in the application:   <pre><code>@HiltAndroidApp\nclass DocuSnapApplication : Application()\n</code></pre></p> </li> <li> <p>Provide dependencies through modules:   <pre><code>@Module\n@InstallIn(SingletonComponent::class)\nobject AppModule {\n    @Provides\n    @Singleton\n    fun provideDocumentRepository(\n        deviceDBService: DeviceDBService\n    ): DocumentRepository = DocumentRepository(deviceDBService)\n\n    // Other dependencies\n}\n</code></pre></p> </li> <li> <p>Inject dependencies into ViewModels and other components:   <pre><code>@HiltViewModel\nclass DocumentViewModel @Inject constructor(\n    private val repository: DocumentRepository\n) : ViewModel()\n</code></pre></p> </li> <li> <p>Benefits:</p> </li> <li>Simplified dependency management</li> <li>Better testability</li> <li>Consistent dependency provision</li> <li>Scope management (singleton, activity, etc.)</li> </ul>"},{"location":"summary/future-optimizations/#3-feature-modularization","title":"3. Feature Modularization","text":"<p>Current Issue: All features are in a single module.</p> <p>Recommendation: Implement feature modules:</p> <ul> <li>Create separate modules for major features:</li> <li><code>:feature:document</code> - Document processing</li> <li><code>:feature:form</code> - Form processing</li> <li><code>:feature:camera</code> - Camera and image capture</li> <li> <p><code>:core:common</code> - Shared components and utilities</p> </li> <li> <p>Benefits:</p> </li> <li>Faster build times</li> <li>Better separation of concerns</li> <li>Supports dynamic feature delivery</li> <li>Enables team to work in parallel</li> </ul>"},{"location":"summary/future-optimizations/#error-handling-enhancement","title":"Error Handling Enhancement","text":""},{"location":"summary/future-optimizations/#1-unified-error-handling-framework","title":"1. Unified Error Handling Framework","text":"<p>Current Issue: Error handling strategies vary between modules.</p> <p>Recommendation: Create a unified error handling framework:</p> <ul> <li> <p>Define a common Result type:   <pre><code>sealed class Result&lt;out T&gt; {\n    data class Success&lt;T&gt;(val data: T) : Result&lt;T&gt;()\n    data class Error(val error: AppError) : Result&lt;Nothing&gt;()\n    object Loading : Result&lt;Nothing&gt;()\n}\n\nsealed class AppError {\n    data class NetworkError(val code: Int, val message: String) : AppError()\n    data class DatabaseError(val operation: String, val message: String) : AppError()\n    data class ProcessingError(val stage: String, val message: String) : AppError()\n    // Other error types\n}\n</code></pre></p> </li> <li> <p>Use consistently throughout the application:   <pre><code>suspend fun getDocument(id: String): Result&lt;Document&gt; {\n    return try {\n        val document = deviceDBService.getDocument(id)?.toDocument()\n            ?: return Result.Error(AppError.DatabaseError(\"getDocument\", \"Document not found\"))\n        Result.Success(document)\n    } catch (e: Exception) {\n        Result.Error(AppError.DatabaseError(\"getDocument\", e.message ?: \"Unknown error\"))\n    }\n}\n</code></pre></p> </li> <li> <p>Benefits:</p> </li> <li>Consistent error handling</li> <li>Better error reporting</li> <li>Improved user experience</li> <li>Easier debugging</li> </ul>"},{"location":"summary/future-optimizations/#2-error-recovery-mechanisms","title":"2. Error Recovery Mechanisms","text":"<p>Current Issue: Limited error recovery options.</p> <p>Recommendation: Implement robust error recovery:</p> <ul> <li> <p>Automatic retry for transient errors:   <pre><code>suspend fun &lt;T&gt; withRetry(\n    times: Int = 3,\n    initialDelay: Long = 100,\n    maxDelay: Long = 1000,\n    factor: Double = 2.0,\n    block: suspend () -&gt; T\n): T {\n    var currentDelay = initialDelay\n    repeat(times - 1) {\n        try {\n            return block()\n        } catch (e: Exception) {\n            // Only retry certain exceptions\n            if (e !is IOException &amp;&amp; e !is HttpException) throw e\n        }\n        delay(currentDelay)\n        currentDelay = (currentDelay * factor).toLong().coerceAtMost(maxDelay)\n    }\n    return block() // last attempt\n}\n</code></pre></p> </li> <li> <p>User-initiated recovery options:</p> </li> <li>Provide retry buttons for failed operations</li> <li>Offer alternative workflows when primary path fails</li> <li> <p>Save draft state to prevent data loss</p> </li> <li> <p>Benefits:</p> </li> <li>Improved application resilience</li> <li>Better user experience</li> <li>Reduced support issues</li> <li>Higher success rate for operations</li> </ul>"},{"location":"summary/future-optimizations/#testing-coverage","title":"Testing Coverage","text":""},{"location":"summary/future-optimizations/#1-increase-unit-test-coverage","title":"1. Increase Unit Test Coverage","text":"<p>Current Issue: Limited unit test coverage.</p> <p>Recommendation: Implement comprehensive unit tests:</p> <ul> <li> <p>Test ViewModels with TestCoroutineDispatcher:   <pre><code>@RunWith(JUnit4::class)\nclass DocumentViewModelTest {\n    @get:Rule\n    val instantTaskExecutorRule = InstantTaskExecutorRule()\n\n    private val testDispatcher = TestCoroutineDispatcher()\n    private val testScope = TestCoroutineScope(testDispatcher)\n\n    private lateinit var repository: DocumentRepository\n    private lateinit var viewModel: DocumentViewModel\n\n    @Before\n    fun setup() {\n        Dispatchers.setMain(testDispatcher)\n        repository = mockk()\n        viewModel = DocumentViewModel(repository)\n    }\n\n    @After\n    fun tearDown() {\n        Dispatchers.resetMain()\n        testScope.cleanupTestCoroutines()\n    }\n\n    @Test\n    fun `loadDocuments should update state with documents from repository`() = testScope.runBlockingTest {\n        // Arrange\n        val documents = listOf(createTestDocument(), createTestDocument())\n        coEvery { repository.getAllDocuments() } returns documents\n\n        // Act\n        viewModel.loadDocuments()\n\n        // Assert\n        assertEquals(documents, viewModel.documents.value)\n        assertEquals(false, viewModel.isLoading.value)\n    }\n}\n</code></pre></p> </li> <li> <p>Test Repositories:   <pre><code>@RunWith(JUnit4::class)\nclass DocumentRepositoryTest {\n    private lateinit var deviceDBService: DeviceDBService\n    private lateinit var repository: DocumentRepository\n\n    @Before\n    fun setup() {\n        deviceDBService = mockk()\n        repository = DocumentRepository(deviceDBService)\n    }\n\n    @Test\n    fun `getAllDocuments should map JSON to Document objects`() = runBlockingTest {\n        // Arrange\n        val jsonArray = JSONArray()\n        // Add test JSON objects\n\n        coEvery { deviceDBService.getDocumentGallery() } returns jsonArray\n\n        // Act\n        val result = repository.getAllDocuments()\n\n        // Assert\n        assertEquals(jsonArray.length(), result.size)\n        // Verify mapping logic\n    }\n}\n</code></pre></p> </li> <li> <p>Benefits:</p> </li> <li>Improved code reliability</li> <li>Regression prevention</li> <li>Better documentation of expected behavior</li> <li>Facilitates refactoring</li> </ul>"},{"location":"summary/future-optimizations/#2-ui-testing","title":"2. UI Testing","text":"<p>Current Issue: Limited UI test coverage.</p> <p>Recommendation: Implement UI tests with Compose testing:</p> <ul> <li> <p>Test Composables:   <pre><code>@RunWith(JUnit4::class)\nclass DocumentScreenTest {\n    @get:Rule\n    val composeTestRule = createComposeRule()\n\n    @Test\n    fun documentScreenShowsLoadingIndicator() {\n        // Arrange\n        val viewModel = mockk&lt;DocumentViewModel&gt;()\n        every { viewModel.isLoading } returns MutableStateFlow(true)\n        every { viewModel.documents } returns MutableStateFlow(emptyList())\n\n        // Act\n        composeTestRule.setContent {\n            DocumentScreen(viewModel = viewModel)\n        }\n\n        // Assert\n        composeTestRule.onNodeWithTag(\"loading_indicator\").assertIsDisplayed()\n    }\n\n    @Test\n    fun documentScreenShowsDocumentList() {\n        // Arrange\n        val documents = listOf(createTestDocument(), createTestDocument())\n        val viewModel = mockk&lt;DocumentViewModel&gt;()\n        every { viewModel.isLoading } returns MutableStateFlow(false)\n        every { viewModel.documents } returns MutableStateFlow(documents)\n\n        // Act\n        composeTestRule.setContent {\n            DocumentScreen(viewModel = viewModel)\n        }\n\n        // Assert\n        composeTestRule.onNodeWithTag(\"document_list\").assertIsDisplayed()\n        composeTestRule.onNodeWithText(documents[0].name).assertIsDisplayed()\n    }\n}\n</code></pre></p> </li> <li> <p>Benefits:</p> </li> <li>Ensures UI behaves as expected</li> <li>Catches regressions in UI behavior</li> <li>Validates user workflows</li> <li>Documents UI requirements</li> </ul>"},{"location":"summary/future-optimizations/#performance-optimization","title":"Performance Optimization","text":""},{"location":"summary/future-optimizations/#1-image-processing-optimization","title":"1. Image Processing Optimization","text":"<p>Current Issue: Image processing could be more efficient.</p> <p>Recommendation: Optimize image processing algorithms:</p> <ul> <li> <p>Use NDK for performance-critical algorithms:   <pre><code>// In build.gradle.kts\nandroid {\n    defaultConfig {\n        externalNativeBuild {\n            cmake {\n                cppFlags += \"-std=c++17\"\n            }\n        }\n    }\n    externalNativeBuild {\n        cmake {\n            path = file(\"src/main/cpp/CMakeLists.txt\")\n        }\n    }\n}\n\n// JNI interface\nexternal fun nativeDetectEdges(bitmap: Bitmap): Array&lt;PointF&gt;\n</code></pre></p> </li> <li> <p>Implement parallel processing for large images:   <pre><code>suspend fun processBitmapInParallel(bitmap: Bitmap): Bitmap = withContext(Dispatchers.Default) {\n    val height = bitmap.height\n    val width = bitmap.width\n    val result = Bitmap.createBitmap(width, height, bitmap.config)\n\n    // Split image into chunks for parallel processing\n    val chunkSize = height / Runtime.getRuntime().availableProcessors()\n    val chunks = (0 until height step chunkSize).map { y -&gt;\n        async {\n            processChunk(bitmap, result, y, minOf(y + chunkSize, height))\n        }\n    }\n\n    // Wait for all chunks to complete\n    chunks.awaitAll()\n\n    return@withContext result\n}\n</code></pre></p> </li> <li> <p>Benefits:</p> </li> <li>Faster processing times</li> <li>Reduced battery consumption</li> <li>Better user experience</li> <li>Support for larger images</li> </ul>"},{"location":"summary/future-optimizations/#2-data-loading-optimization","title":"2. Data Loading Optimization","text":"<p>Current Issue: Data loading could be more efficient.</p> <p>Recommendation: Implement pagination and efficient data loading:</p> <ul> <li> <p>Add pagination to data loading:   <pre><code>@Dao\ninterface DocumentDao {\n    @Query(\"SELECT * FROM documents ORDER BY last_used DESC LIMIT :limit OFFSET :offset\")\n    fun getDocumentsPaged(limit: Int, offset: Int): Flow&lt;List&lt;DocumentEntity&gt;&gt;\n}\n\n// In Repository\nfun getPagedDocuments(page: Int, pageSize: Int = 20): Flow&lt;List&lt;Document&gt;&gt; {\n    return documentDao.getDocumentsPaged(pageSize, page * pageSize)\n        .map { entities -&gt; entities.map { it.toDocument() } }\n}\n</code></pre></p> </li> <li> <p>Implement efficient data loading with Paging 3:   <pre><code>@Dao\ninterface DocumentDao {\n    @Query(\"SELECT * FROM documents ORDER BY last_used DESC\")\n    fun getDocumentsPagingSource(): PagingSource&lt;Int, DocumentEntity&gt;\n}\n\n// In Repository\nfun getDocumentsStream(): Flow&lt;PagingData&lt;Document&gt;&gt; {\n    return Pager(\n        config = PagingConfig(\n            pageSize = 20,\n            enablePlaceholders = true,\n            maxSize = 100\n        ),\n        pagingSourceFactory = { documentDao.getDocumentsPagingSource() }\n    ).flow.map { pagingData -&gt;\n        pagingData.map { it.toDocument() }\n    }\n}\n</code></pre></p> </li> <li> <p>Benefits:</p> </li> <li>Reduced memory usage</li> <li>Faster initial loading</li> <li>Smoother scrolling experience</li> <li>Better handling of large datasets</li> </ul>"},{"location":"summary/future-optimizations/#cicd-implementation","title":"CI/CD Implementation","text":""},{"location":"summary/future-optimizations/#1-automated-build-pipeline","title":"1. Automated Build Pipeline","text":"<p>Current Issue: No automated build process.</p> <p>Recommendation: Implement CI/CD pipeline with GitHub Actions:</p> <ul> <li> <p>Create workflow file:   <pre><code>name: Android CI\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Set up JDK\n        uses: actions/setup-java@v3\n        with:\n          java-version: '11'\n          distribution: 'temurin'\n\n      - name: Grant execute permission for gradlew\n        run: chmod +x gradlew\n\n      - name: Build with Gradle\n        run: ./gradlew build\n\n      - name: Run tests\n        run: ./gradlew test\n\n      - name: Build debug APK\n        run: ./gradlew assembleDebug\n\n      - name: Upload APK\n        uses: actions/upload-artifact@v3\n        with:\n          name: app-debug\n          path: app/build/outputs/apk/debug/app-debug.apk\n</code></pre></p> </li> <li> <p>Benefits:</p> </li> <li>Automated build verification</li> <li>Early detection of issues</li> <li>Consistent build environment</li> <li>Improved team productivity</li> </ul>"},{"location":"summary/future-optimizations/#2-automated-testing","title":"2. Automated Testing","text":"<p>Current Issue: No automated testing in the build process.</p> <p>Recommendation: Add automated testing to the CI pipeline:</p> <ul> <li> <p>Add UI tests to CI:   <pre><code>- name: Run instrumentation tests\n  uses: reactivecircus/android-emulator-runner@v2\n  with:\n    api-level: 29\n    script: ./gradlew connectedAndroidTest\n</code></pre></p> </li> <li> <p>Add code coverage reporting:   <pre><code>- name: Generate code coverage report\n  run: ./gradlew jacocoTestReport\n\n- name: Upload coverage to Codecov\n  uses: codecov/codecov-action@v3\n</code></pre></p> </li> <li> <p>Benefits:</p> </li> <li>Ensures tests are run consistently</li> <li>Provides visibility into test coverage</li> <li>Catches regressions early</li> <li>Improves code quality</li> </ul>"},{"location":"summary/future-optimizations/#monitoring-and-analytics","title":"Monitoring and Analytics","text":""},{"location":"summary/future-optimizations/#1-performance-monitoring","title":"1. Performance Monitoring","text":"<p>Current Issue: Limited visibility into app performance.</p> <p>Recommendation: Implement performance monitoring:</p> <ul> <li> <p>Add Firebase Performance Monitoring:   <pre><code>// In Application class\nFirebasePerformance.getInstance().isPerformanceCollectionEnabled = true\n\n// Custom trace for important operations\nval trace = FirebasePerformance.getInstance().newTrace(\"image_processing\")\ntrace.start()\n// Perform operation\ntrace.stop()\n</code></pre></p> </li> <li> <p>Monitor key metrics:</p> </li> <li>Startup time</li> <li>Screen rendering time</li> <li>Network request latency</li> <li> <p>Image processing duration</p> </li> <li> <p>Benefits:</p> </li> <li>Identify performance bottlenecks</li> <li>Track performance over time</li> <li>Prioritize optimization efforts</li> <li>Improve user experience</li> </ul>"},{"location":"summary/future-optimizations/#2-crash-reporting","title":"2. Crash Reporting","text":"<p>Current Issue: Limited crash visibility.</p> <p>Recommendation: Implement crash reporting:</p> <ul> <li> <p>Add Firebase Crashlytics:   <pre><code>// In Application class\nFirebaseCrashlytics.getInstance().setCrashlyticsCollectionEnabled(true)\n\n// Log non-fatal exceptions\ntry {\n    // Risky operation\n} catch (e: Exception) {\n    FirebaseCrashlytics.getInstance().recordException(e)\n    // Handle exception\n}\n</code></pre></p> </li> <li> <p>Add custom keys for debugging:   <pre><code>FirebaseCrashlytics.getInstance().setCustomKey(\"document_id\", documentId)\nFirebaseCrashlytics.getInstance().setCustomKey(\"processing_stage\", \"edge_detection\")\n</code></pre></p> </li> <li> <p>Benefits:</p> </li> <li>Faster issue detection</li> <li>Better debugging information</li> <li>Prioritization of critical issues</li> <li>Improved application stability</li> </ul> <p>These optimization recommendations provide a roadmap for future improvements to DocuSnap-Frontend, focusing on code quality, performance, testing, and development processes. Implementing these recommendations will enhance the application's maintainability, reliability, and user experience.</p>"},{"location":"summary/quick-start-guide/","title":"Quick Start Guide","text":"<p>This guide provides essential information for new developers to quickly get started with the DocuSnap-Frontend project.</p>"},{"location":"summary/quick-start-guide/#key-components-and-files","title":"Key Components and Files","text":""},{"location":"summary/quick-start-guide/#1-entry-points","title":"1. Entry Points","text":"<ul> <li>MainActivity.kt: Main application entry point</li> <li>Initializes the application</li> <li>Sets up the navigation host</li> <li> <p>Configures dependencies</p> </li> <li> <p>AppModule.kt: Dependency injection configuration</p> </li> <li>Provides application-wide dependencies</li> <li>Configures services and repositories</li> <li>Manages singleton instances</li> </ul>"},{"location":"summary/quick-start-guide/#2-core-modules","title":"2. Core Modules","text":"<ul> <li>DocumentViewModel.kt: Core of document processing</li> <li>Manages document state and operations</li> <li>Handles document loading, saving, and updating</li> <li> <p>Coordinates with repositories for data operations</p> </li> <li> <p>ImageProcessingViewModel.kt: Core of image processing</p> </li> <li>Manages image processing state and operations</li> <li>Handles image filters and transformations</li> <li> <p>Coordinates with image processing services</p> </li> <li> <p>BackendApiService.kt: Core of backend communication</p> </li> <li>Manages API requests and responses</li> <li>Implements encryption and security</li> <li>Handles error cases and retries</li> </ul>"},{"location":"summary/quick-start-guide/#3-data-models","title":"3. Data Models","text":"<ul> <li>Document.kt: Document data model</li> <li>Defines document structure and properties</li> <li> <p>Used throughout the document processing flow</p> </li> <li> <p>Form.kt: Form data model</p> </li> <li>Defines form structure and properties</li> <li> <p>Includes form fields and metadata</p> </li> <li> <p>ExtractedInfoItem.kt: Extracted information model</p> </li> <li>Represents extracted text or field data</li> <li>Used in both documents and forms</li> </ul>"},{"location":"summary/quick-start-guide/#4-ui-components","title":"4. UI Components","text":"<ul> <li>screens/: Main screen implementations</li> <li>Contains all application screens</li> <li> <p>Organized by feature or function</p> </li> <li> <p>components/: Reusable UI components</p> </li> <li>Contains shared UI elements</li> <li> <p>Used across multiple screens</p> </li> <li> <p>theme/: Application theme and styles</p> </li> <li>Defines colors, typography, and shapes</li> <li>Configures Material Design theme</li> </ul>"},{"location":"summary/quick-start-guide/#development-environment-setup","title":"Development Environment Setup","text":""},{"location":"summary/quick-start-guide/#1-environment-requirements","title":"1. Environment Requirements","text":"<ul> <li>Android Studio: Arctic Fox or higher</li> <li>JDK: Version 11 or higher</li> <li>Android SDK: API level 33 or higher</li> <li>Gradle: Compatible with project configuration</li> </ul>"},{"location":"summary/quick-start-guide/#2-build-steps","title":"2. Build Steps","text":"<ol> <li> <p>Clone the Repository:    <pre><code>git clone https://github.com/JI-DeepSleep/DocuSnap-Frontend.git\ncd DocuSnap-Frontend\n</code></pre></p> </li> <li> <p>Open in Android Studio:</p> </li> <li>Launch Android Studio</li> <li>Select \"Open an Existing Project\"</li> <li> <p>Navigate to the cloned repository directory</p> </li> <li> <p>Sync Gradle Files:</p> </li> <li>Wait for the automatic sync or</li> <li> <p>Click \"Sync Project with Gradle Files\" button</p> </li> <li> <p>Build and Run:</p> </li> <li>Select a device or emulator</li> <li>Click the \"Run\" button or press Shift+F10</li> </ol>"},{"location":"summary/quick-start-guide/#3-debugging-tips","title":"3. Debugging Tips","text":"<ul> <li>Logcat: Use for viewing logs</li> <li>Filter by tag to focus on specific components</li> <li> <p>Use different log levels (DEBUG, INFO, ERROR)</p> </li> <li> <p>Layout Inspector: Debug UI issues</p> </li> <li>View component hierarchy</li> <li> <p>Inspect properties and constraints</p> </li> <li> <p>Database Inspector: View database content</p> </li> <li>Examine tables and records</li> <li> <p>Execute SQL queries for testing</p> </li> <li> <p>Network Profiler: Monitor network activity</p> </li> <li>Track API calls</li> <li>Analyze response times and data sizes</li> </ul>"},{"location":"summary/quick-start-guide/#common-development-workflows","title":"Common Development Workflows","text":""},{"location":"summary/quick-start-guide/#1-adding-a-new-screen","title":"1. Adding a New Screen","text":"<ol> <li> <p>Create a new Composable function in the <code>screens/</code> directory:    <pre><code>@Composable\nfun NewScreen(\n    viewModel: SharedViewModel = hiltViewModel(),\n    onNavigate: (String) -&gt; Unit\n) {\n    // Screen implementation\n}\n</code></pre></p> </li> <li> <p>Add a new route in the navigation package:    <pre><code>object Screen {\n    // Existing routes\n    object NewScreen : Screen(\"new_screen\")\n}\n</code></pre></p> </li> <li> <p>Register the screen in the NavHost:    <pre><code>NavHost(\n    navController = navController,\n    startDestination = startDestination\n) {\n    // Existing routes\n    composable(Screen.NewScreen.route) {\n        NewScreen(\n            onNavigate = { route -&gt; navController.navigate(route) }\n        )\n    }\n}\n</code></pre></p> </li> </ol>"},{"location":"summary/quick-start-guide/#2-modifying-data-models","title":"2. Modifying Data Models","text":"<ol> <li> <p>Update the data class definition:    <pre><code>@Serializable\ndata class Document(\n    val id: String,\n    val name: String,\n    // Add new fields\n    val newField: String? = null,\n    // Other existing fields\n)\n</code></pre></p> </li> <li> <p>Update corresponding database entity if needed:    <pre><code>@Entity(tableName = \"documents\")\ndata class DocumentEntity(\n    @PrimaryKey val id: String,\n    val name: String,\n    // Add new column\n    @ColumnInfo(name = \"new_field\") val newField: String?,\n    // Other existing columns\n)\n</code></pre></p> </li> <li> <p>Add database migration strategy:    <pre><code>val MIGRATION_1_2 = object : Migration(1, 2) {\n    override fun migrate(database: SupportSQLiteDatabase) {\n        database.execSQL(\"ALTER TABLE documents ADD COLUMN new_field TEXT\")\n    }\n}\n</code></pre></p> </li> </ol>"},{"location":"summary/quick-start-guide/#3-adding-new-functionality","title":"3. Adding New Functionality","text":"<ol> <li> <p>Determine which module the functionality belongs to</p> </li> <li> <p>Add necessary methods to the appropriate ViewModel:    <pre><code>// In DocumentViewModel\nfun newFeature(param: String) {\n    viewModelScope.launch {\n        _isLoading.value = true\n        try {\n            val result = repository.performNewFeature(param)\n            _featureResult.value = result\n        } catch (e: Exception) {\n            _error.value = \"Error: ${e.message}\"\n        } finally {\n            _isLoading.value = false\n        }\n    }\n}\n</code></pre></p> </li> <li> <p>Update the UI to support the new feature:    <pre><code>@Composable\nfun FeatureComponent(viewModel: DocumentViewModel) {\n    val result by viewModel.featureResult.collectAsState()\n\n    Column {\n        Button(onClick = { viewModel.newFeature(\"param\") }) {\n            Text(\"Execute New Feature\")\n        }\n\n        if (result != null) {\n            Text(\"Result: $result\")\n        }\n    }\n}\n</code></pre></p> </li> </ol>"},{"location":"summary/quick-start-guide/#architecture-overview","title":"Architecture Overview","text":"<p>DocuSnap-Frontend follows the MVVM (Model-View-ViewModel) architecture pattern:</p> <ol> <li>Model: Data models and repositories</li> <li>Represents the data and business logic</li> <li> <p>Handles data access and storage</p> </li> <li> <p>View: Jetpack Compose UI components</p> </li> <li>Displays data to the user</li> <li> <p>Forwards user actions to the ViewModel</p> </li> <li> <p>ViewModel: State management and business logic</p> </li> <li>Manages UI state</li> <li>Processes user actions</li> <li>Communicates with repositories</li> </ol> <p>Data flows through the application in a unidirectional pattern: - User actions in the UI trigger ViewModel methods - ViewModel processes actions and updates state - UI automatically updates to reflect the new state</p>"},{"location":"summary/quick-start-guide/#common-pitfalls-and-solutions","title":"Common Pitfalls and Solutions","text":""},{"location":"summary/quick-start-guide/#1-state-management","title":"1. State Management","text":"<p>Pitfall: Mutable state shared across multiple components</p> <p>Solution: Use StateFlow in ViewModels and collect at the UI level: <pre><code>// In ViewModel\nprivate val _state = MutableStateFlow(initialState)\nval state: StateFlow&lt;UiState&gt; = _state.asStateFlow()\n\n// In UI\nval state by viewModel.state.collectAsState()\n</code></pre></p>"},{"location":"summary/quick-start-guide/#2-coroutine-scope","title":"2. Coroutine Scope","text":"<p>Pitfall: Using the wrong coroutine scope or not cancelling coroutines</p> <p>Solution: Use the appropriate scope and ensure proper cancellation: <pre><code>// In ViewModel\nviewModelScope.launch {\n    // Long-running operation\n}\n// Automatically cancelled when ViewModel is cleared\n\n// For background service\nval job = CoroutineScope(Dispatchers.IO + SupervisorJob()).launch {\n    // Background operation\n}\n// Remember to cancel: job.cancel()\n</code></pre></p>"},{"location":"summary/quick-start-guide/#3-image-processing-performance","title":"3. Image Processing Performance","text":"<p>Pitfall: Performing heavy image processing on the main thread</p> <p>Solution: Use background dispatchers and optimize processing: <pre><code>viewModelScope.launch(Dispatchers.IO) {\n    val processedBitmap = withContext(Dispatchers.Default) {\n        // Heavy image processing\n        imageProcService.processImage(bitmap)\n    }\n\n    // Update UI state on main thread\n    _uiState.update { it.copy(editingBitmap = processedBitmap) }\n}\n</code></pre></p>"},{"location":"summary/quick-start-guide/#4-memory-management","title":"4. Memory Management","text":"<p>Pitfall: Memory leaks from holding references to contexts or activities</p> <p>Solution: Use application context, weak references, or lifecycle-aware components: <pre><code>// Use application context for long-lived objects\nval imageLoader = ImageLoader(context.applicationContext)\n\n// Use rememberCoroutineScope in Compose\nval scope = rememberCoroutineScope()\n</code></pre></p> <p>This quick start guide should help new developers understand the key components of DocuSnap-Frontend and get started with common development tasks. For more detailed information, refer to the specific documentation sections on architecture, modules, and processes.</p>"},{"location":"technology/selection-rationale/","title":"Technology Selection Rationale and Advantages","text":"<p>This section explains the reasoning behind the technology choices made for DocuSnap-Frontend and the advantages these technologies bring to the application.</p>"},{"location":"technology/selection-rationale/#jetpack-compose","title":"Jetpack Compose","text":"<p>Rationale: Traditional XML layout systems are complex and difficult to maintain, especially for complex UI interactions.</p> <p>Advantages: - Declarative UI simplifies building complex interfaces - Built-in animation and state management - Seamless integration with Kotlin, improving development efficiency - Reduced boilerplate code, improving readability - Real-time preview, accelerating development iteration</p>"},{"location":"technology/selection-rationale/#mvvm-architecture","title":"MVVM Architecture","text":"<p>Rationale: Need for clear separation of UI, business logic, and data access.</p> <p>Advantages: - Separation of concerns, improving code maintainability - Support for unit testing, improving code quality - Clear UI state management, reducing state-related bugs - Well-suited for data-driven application scenarios - Compatible with the Jetpack component ecosystem</p>"},{"location":"technology/selection-rationale/#kotlin-coroutines","title":"Kotlin Coroutines","text":"<p>Rationale: Asynchronous operations (such as network requests, database access) need a concise handling approach.</p> <p>Advantages: - Simplifies asynchronous programming, avoiding callback hell - Structured concurrency, making lifecycle management easier - Combined with Flow, supports reactive programming - Reduces the complexity of thread management - Improves code readability and maintainability</p>"},{"location":"technology/selection-rationale/#room-database","title":"Room Database","text":"<p>Rationale: Need for reliable local data storage and offline functionality support.</p> <p>Advantages: - Type-safe data access - Compile-time SQL validation - Seamless integration with Kotlin Coroutines and Flow - Simplified database migration - Support for complex queries and relationship mapping</p>"},{"location":"technology/selection-rationale/#camerax","title":"CameraX","text":"<p>Rationale: Need for stable, consistent camera experience while simplifying camera operations.</p> <p>Advantages: - Simplifies camera lifecycle management - Cross-device consistency - Built-in common use cases (preview, photo capture, video recording) - Integration with Jetpack lifecycle components - Support for image analysis and extension features</p> <p>These technology choices reflect a careful consideration of the application's requirements, modern Android development best practices, and the need for a maintainable, efficient, and user-friendly application.</p>"},{"location":"technology/technology-selection/","title":"Technology Selection by Layer","text":"<p>DocuSnap-Frontend employs a layered architecture with carefully selected technologies for each layer. This approach ensures separation of concerns and enables the use of the most appropriate technologies for specific requirements.</p>"},{"location":"technology/technology-selection/#ui-layer","title":"UI Layer","text":"<ul> <li>Jetpack Compose: Modern declarative UI framework providing reactive UI building capabilities</li> <li>Material Design 3: Latest Material design specification offering a modern visual experience</li> <li>Navigation Compose: Type-safe navigation framework simplifying screen navigation</li> <li>Coil: Efficient image loading library optimizing image display performance</li> </ul>"},{"location":"technology/technology-selection/#business-logic-layer","title":"Business Logic Layer","text":"<ul> <li>Jetpack ViewModel: Manages UI-related data and handles configuration changes</li> <li>Kotlin Coroutines: Simplifies asynchronous programming with structured concurrency</li> <li>Flow: Reactive programming framework supporting data stream processing</li> <li>StateFlow: Reactive state container simplifying state management</li> </ul>"},{"location":"technology/technology-selection/#data-layer","title":"Data Layer","text":"<ul> <li>Room Database: Provides type-safe data access, supporting SQLite operations</li> <li>Retrofit: Type-safe HTTP client simplifying network requests</li> <li>OkHttp: Efficient HTTP client providing interceptors and cache support</li> <li>Kotlinx Serialization: High-performance JSON serialization library</li> <li>Moshi: Flexible JSON parsing library seamlessly integrated with Retrofit</li> </ul>"},{"location":"technology/technology-selection/#image-processing","title":"Image Processing","text":"<ul> <li>CameraX API: Simplifies camera operations, providing consistent user experience</li> <li>Custom Image Processing Algorithms: Edge detection, perspective correction, image enhancement, etc.</li> <li>Bitmap Processing: Image scaling, cropping, filter application, etc.</li> </ul>"},{"location":"technology/technology-selection/#secure-communication","title":"Secure Communication","text":"<ul> <li>RSA/AES Encryption: Hybrid encryption system protecting data transmission security</li> <li>SHA-256 Hash Verification: Ensures data integrity</li> <li>HTTPS Communication: Secure network transport layer</li> </ul> <p>The selection of these technologies creates a modern, robust, and maintainable application architecture that leverages the best practices in Android development.</p>"}]}